<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>åç¨‹ on feileo</title>
    <link>https://at7h.com/tags/%E5%8D%8F%E7%A8%8B/</link>
    <description>Recent content in åç¨‹ on feileo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 10 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://at7h.com/tags/%E5%8D%8F%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python3 åç¨‹(coroutine)ä»‹ç»</title>
      <link>https://at7h.com/posts/coroutine/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/coroutine/</guid>
      <description>ç›®å‰ Python è¯­è¨€çš„åç¨‹ä»å®ç°æ¥è¯´å¯åˆ†ä¸ºä¸¤ç±»ï¼š ä¸€ç§æ˜¯åŸºäºä¼ ç»Ÿç”Ÿæˆå™¨çš„åç¨‹ï¼Œå«åš generator-based coroutinesï¼Œé€šè¿‡åŒ…è£… generator å¯¹è±¡å®ç°ã€‚ å¦ä¸€ç§åœ¨ Python 3.5 ç‰ˆæœ¬ PEP 492 è¯ç”Ÿï¼Œå«åš native coroutinesï¼Œå³é€šè¿‡ä½¿ç”¨ async è¯­æ³•æ¥å£°æ˜çš„åç¨‹ã€‚ æœ¬æ–‡ä¸»è¦ä»‹ç»ç¬¬äºŒç§ï¼Œç¬¬ä¸€ç§åŸºäºç”Ÿæˆå™¨çš„åç¨‹å·²åœ¨ Python 3.8 ä¸­å¼ƒç”¨ï¼Œå¹¶è®¡åˆ’åœ¨ Python 3.10 ä¸­ç§»é™¤ã€‚æœ¬æ–‡æ˜¯ã€Œä»‹ç»ã€ï¼Œå°±å…ˆä¸è®¨è®ºå¤ªå¤šå®ç°åŸç†çš„ä¸œè¥¿ï¼Œæ„Ÿå…´è¶£çš„ç«¥é‹å¯ä»¥ç»§ç»­å…³æ³¨åé¢çš„æ–‡ç« ã€‚ åç¨‹(coroutine) é¦–å…ˆï¼Œæ¥çœ‹ä¸€ä¸ªéå¸¸ç®€å•çš„ä¾‹å­ï¼š import asyncio async def c(): await asyncio.sleep(1) return &amp;#39;Done ğŸ‘Œ&amp;#39; è¿™ä¸ªè¢« async ä¿®é¥°çš„å‡½æ•° c å°±æ˜¯ä¸€ä¸ªåç¨‹å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªåç¨‹å¯¹è±¡ã€‚ In [1]: asyncio.iscoroutinefunction(c) Out[1]: True In [2]: c() Out[2]: &amp;lt;coroutine object c at 0x107b0f748&amp;gt; In [3]: asyncio.iscoroutine(c()) Out[3]: True ä¸€èˆ¬æ¥è¯´ï¼Œåç¨‹å‡½æ•° c åº”å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š ä¸€å®šä¼šè¿”å›ä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œè€Œä¸ç®¡å…¶ä¸­æ˜¯å¦æœ‰ await è¡¨è¾¾å¼ã€‚ å‡½æ•°ä¸­ä¸èƒ½å†ä½¿ç”¨ yield fromã€‚ å‡½æ•°å†…éƒ¨å¯é€šè¿‡ await è¡¨è¾¾å¼æ¥æŒ‚èµ·è‡ªèº«åç¨‹ï¼Œå¹¶ç­‰å¾…å¦ä¸€ä¸ªåç¨‹å®Œæˆç›´åˆ°è¿”å›ç»“æœã€‚ await è¡¨è¾¾å¼åé¢å¯ä»¥è·Ÿçš„ä¸€å®šæ˜¯ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ï¼Œè€Œä¸ä»…ä»…æ˜¯åç¨‹å¯¹è±¡ã€‚ ä¸å¯åœ¨ async ä¿®é¥°çš„åç¨‹å‡½æ•°å¤–ä½¿ç”¨ await å…³é”®å­—ï¼Œå¦åˆ™ä¼šå¼•å‘ä¸€ä¸ª SyntaxErrorã€‚ å½“å¯¹åç¨‹å¯¹è±¡è¿›è¡Œåƒåœ¾æ”¶é›†æ—¶ï¼Œå¦‚æœä»æœªç­‰å¾…è¿‡å®ƒï¼Œåˆ™ä¼šå¼•å‘ä¸€ä¸ª RuntimeWarningï¼ˆå¦‚æœä½ åˆšå¼€å§‹å†™ asyncï¼Œé‚£ä½ ä¸€å®šé‡å¾—åˆ°ï¼Œä¸ç»æ„é—´å°±ä¼šå¿˜æ‰ä¸€ä¸ª await)ã€‚ ä¸‹é¢åˆ†åˆ«ä»‹ç»ä¸‹ä¸Šé¢æåˆ°çš„ä¸¤ä¸ªæ¦‚å¿µï¼Œå¯ç­‰å¾…å¯¹è±¡å’Œåç¨‹å¯¹è±¡ã€‚ å¯ç­‰å¾…å¯¹è±¡(awaitable) æˆ‘ä»¬æ¥çœ‹ collections.abc æ¨¡å—ä¸­å¯¹ Awaitable ç±»çš„å®šä¹‰ï¼š class Awaitable(metaclass=ABCMeta): __slots__ = () @abstractmethod def __await__(self): yield @classmethod def __subclasshook__(cls, C): if cls is Awaitable: return _check_methods(C, &amp;#34;__await__&amp;#34;) return NotImplemented å¯è§ï¼Œå¯ç­‰å¾…å¯¹è±¡ä¸»è¦å®ç°äº†ä¸€ä¸ª __await__ æ–¹æ³•ã€‚ä¸”è¯¥æ–¹æ³•å¿…é¡»è¿”å›ä¸€ä¸ªè¿­ä»£å™¨(iterator) â‘ ï¼Œå¦åˆ™å°†ä¼šå¼•å‘ä¸€ä¸ª TypeErrorã€‚ æ³¨æ„ï¼šä¸»è¦å®ç°æ˜¯å› ä¸º await è¡¨è¾¾å¼éœ€è¦è·Ÿè€çš„åŸºäºç”Ÿæˆå™¨çš„åç¨‹ç›¸å…¼å®¹ï¼Œå³é€šè¿‡ä½¿ç”¨ types.coroutine() æˆ– asyncio.coroutine() è£…é¥°å™¨è¿”å›çš„ç”Ÿæˆå™¨è¿­ä»£å™¨å¯¹è±¡(generator iterator)ä¹Ÿå±äºå¯ç­‰å¾…å¯¹è±¡ï¼Œä½†å®ƒä»¬å¹¶æœªå®ç° __await__ æ–¹æ³•ã€‚ åç¨‹å¯¹è±¡(Coroutine) åŒæ ·çš„ï¼Œæˆ‘ä»¬æ¥çœ‹ collections.abc æ¨¡å—ä¸­å¯¹ Coroutine ç±»çš„å®šä¹‰ï¼š class Coroutine(Awaitable): __slots__ = () @abstractmethod def send(self, value): &amp;#34;&amp;#34;&amp;#34;Send a value into the coroutine. Return next yielded value or raise StopIteration. &amp;#34;&amp;#34;&amp;#34; raise StopIteration @abstractmethod def throw(self, typ, val=None, tb=None): &amp;#34;&amp;#34;&amp;#34;Raise an exception in the coroutine. Return next yielded value or raise StopIteration. &amp;#34;&amp;#34;&amp;#34; if val is None: if tb is None: raise typ val = typ() if tb is not None: val = val.with_traceback(tb) raise val def close(self): &amp;#34;&amp;#34;&amp;#34;Raise GeneratorExit inside coroutine. &amp;#34;&amp;#34;&amp;#34; try: self.throw(GeneratorExit) except (GeneratorExit, StopIteration): pass else: raise RuntimeError(&amp;#34;coroutine ignored GeneratorExit&amp;#34;) @classmethod def __subclasshook__(cls, C): if cls is Coroutine: return _check_methods(C, &amp;#39;__await__&amp;#39;, &amp;#39;send&amp;#39;, &amp;#39;throw&amp;#39;, &amp;#39;close&amp;#39;) return NotImplemented ç”±ä¸Šå¯çŸ¥ï¼Œç”±äºç»§æ‰¿å…³ç³»ï¼Œåç¨‹å¯¹è±¡æ˜¯å±äºå¯ç­‰å¾…å¯¹è±¡çš„ã€‚ é™¤äº†åç¨‹ Coroutine å¯¹è±¡å¤–ï¼Œç›®å‰å¸¸è§çš„å¯ç­‰å¾…å¯¹è±¡è¿˜æœ‰ä¸¤ç§ï¼šasyncio.Task å’Œ asyncio.Futureï¼Œä¸‹æ–‡ä¸­ä»‹ç»ã€‚ åç¨‹çš„æ‰§è¡Œå¯é€šè¿‡è°ƒç”¨ __await__() å¹¶è¿­ä»£å…¶ç»“æœè¿›è¡Œæ§åˆ¶ã€‚å½“åç¨‹ç»“æŸæ‰§è¡Œå¹¶è¿”å›æ—¶ï¼Œè¿­ä»£å™¨ä¼šå¼•å‘ StopIteration å¼‚å¸¸ï¼Œå¹¶é€šè¿‡è¯¥å¼‚å¸¸çš„ value å±æ€§æ¥ä¼ æ’­åç¨‹çš„è¿”å›å€¼ã€‚ä¸‹é¢çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š In [4]: c().send(None) Out[4]: &amp;lt;Future pending&amp;gt; In [5]: async def c1(): ...: return &amp;#34;Done ğŸ‘Œ&amp;#34; ...: In [6]: c1().send(None) Out[6]: StopIteration: Done ğŸ‘Œ è¿è¡Œ åç¨‹çš„è¿è¡Œéœ€è¦åœ¨ä¸€ä¸ª EventLoop ä¸­è¿›è¡Œï¼Œç”±å®ƒæ¥æ§åˆ¶å¼‚æ­¥ä»»åŠ¡çš„æ³¨å†Œã€æ‰§è¡Œã€å–æ¶ˆç­‰ã€‚å…¶å¤§è‡´åŸç†æ˜¯ï¼š æŠŠä¼ å…¥çš„æ‰€æœ‰å¼‚æ­¥å¯¹è±¡(å‡†ç¡®çš„è¯´æ˜¯å¯ç­‰å¾…å¯¹è±¡ï¼Œå¦‚ Coroutineï¼ŒTask ç­‰ï¼Œè§ä¸‹æ–‡)éƒ½æ³¨å†Œåˆ°è¿™ä¸ª EventLoop ä¸Šï¼ŒEventLoop ä¼šå¾ªç¯æ‰§è¡Œè¿™äº›å¼‚æ­¥å¯¹è±¡ï¼Œä½†åŒæ—¶åªæ‰§è¡Œä¸€ä¸ªï¼Œå½“æ‰§è¡Œåˆ°æŸä¸ªå¯¹è±¡æ—¶ï¼Œå¦‚æœå®ƒæ­£åœ¨ç­‰å¾…å…¶ä»–å¯¹è±¡ï¼ˆI/O å¤„ç†ï¼‰ è¿”å›ï¼Œäº‹ä»¶å¾ªç¯ä¼šæš‚åœå®ƒçš„æ‰§è¡Œå»æ‰§è¡Œå…¶ä»–çš„å¯¹è±¡ã€‚å½“æŸä¸ªå¯¹è±¡å®Œæˆ I/O å¤„ç†åï¼Œä¸‹æ¬¡å¾ªç¯åˆ°å®ƒçš„æ—¶å€™ä¼šè·å–å…¶è¿”å›å€¼ç„¶åç»§ç»­å‘ä¸‹æ‰§è¡Œã€‚è¿™æ ·ä»¥æ¥ï¼Œæ‰€æœ‰çš„å¼‚æ­¥ä»»åŠ¡å°±å¯ä»¥ååŒè¿è¡Œã€‚ EventLoop æ¥å—çš„å¯¹è±¡å¿…é¡»ä¸ºå¯ç­‰å¾…å¯¹è±¡ï¼Œç›®å‰ä¸»è¦æœ‰ä¸‰ç§ç±»å‹å³ Coroutine, Task å’Œ Futureã€‚ ä¸‹é¢ç®€å•çš„ä»‹ç»ä¸‹ Task å’Œ Futureï¼š Future æ˜¯ä¸€ç§ç‰¹æ®Šçš„ä½çº§çš„å¯ç­‰å¾…å¯¹è±¡ï¼Œç”¨æ¥æ”¯æŒåº•å±‚å›è°ƒå¼ä»£ç ä¸é«˜å±‚ async/await å¼çš„ä»£ç äº¤äº’ï¼Œæ˜¯å¯¹åç¨‹åº•å±‚å®ç°çš„å°è£…ï¼Œå…¶è¡¨ç¤ºä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„æœ€ç»ˆç»“æœã€‚å®ƒæä¾›äº†è®¾ç½®å’Œè·å– Future æ‰§è¡ŒçŠ¶æ€æˆ–ç»“æœç­‰æ“ä½œçš„æ¥å£ã€‚Future å®ç°äº† __await__ åè®®ï¼Œå¹¶é€šè¿‡ __iter__ = __await__ æ¥å…¼å®¹è€å¼åç¨‹ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬ä¸éœ€è¦å…³å¿ƒè¿™ç©æ„å„¿ï¼Œæ—¥å¸¸çš„å¼€å‘ä¹Ÿæ˜¯ä¸éœ€è¦è¦ç”¨åˆ°å®ƒçš„ã€‚å¦‚æœ‰éœ€è¦ï¼Œå°±ç”¨å…¶å­ç±» Taskã€‚ Task ç”¨æ¥ååŒçš„è°ƒåº¦åç¨‹ä»¥å®ç°å¹¶å‘ï¼Œå¹¶æä¾›äº†ç›¸åº”çš„æ¥å£ä¾›æˆ‘ä»¬ä½¿ç”¨ã€‚ åˆ›å»ºä¸€ä¸ª Task éå¸¸ç®€å•ï¼š In [6]: loop = asyncio.get_event_loop() In [7]: task = loop.create_task(c()) In [8]: task Out[8]: &amp;lt;Task pending coro=&amp;lt;c() running at &amp;lt;ipython-input-1-3afd2bbb1944&amp;gt;:3&amp;gt;&amp;gt; In [9]: task.done() Out[9]: False In [10]: task.cancelled() Out[10]: False In [11]: task.result() Out[11]: InvalidStateError: Result is not set. In [12]: await task Out[12]: &amp;#39;Done ğŸ‘Œ&amp;#39; In [13]: task Out[13]: &amp;lt;Task finished coro=&amp;lt;c() done, defined at &amp;lt;ipython-input-1-3afd2bbb1944&amp;gt;:3&amp;gt; result=&amp;#39;Done ğŸ‘Œ&amp;#39;&amp;gt; In [14]: task.done() Out[14]: True In [15]: task.result() Out[15]: &amp;#39;Done ğŸ‘Œ&amp;#39; In [16]: task = loop.create_task(c()) In [17]: task.cancel() Out[17]: True In [18]: await task Out[18]: CancelledError: ä¸Šé¢è¯´åˆ°ï¼Œåç¨‹çš„è¿è¡Œéœ€è¦åœ¨ä¸€ä¸ª EventLoop ä¸­è¿›è¡Œï¼Œåœ¨ Python 3.7 ä¹‹å‰ï¼Œä½ åªèƒ½è¿™ä¹ˆå†™ ğŸ˜” : In [19]: loop = asyncio.get_event_loop() In [20]: loop.run_until_complete(c()) Out[20]: &amp;#39;Done ğŸ‘Œ&amp;#39; In [21]: loop.close() Python 3.7 åŠä»¥ä¸Šç‰ˆæœ¬å¯ä»¥ç›´æ¥ä½¿ç”¨ asyncio.run() ğŸ‘ : In [22]: asyncio.run(c()) Out[22]: &amp;#39;Done ğŸ‘Œ&amp;#39; å¹¶å‘ æœ‰äº›ç«¥é‹å¯èƒ½æœ‰ç–‘é—®äº†ï¼Œæˆ‘å†™å¥½äº†ä¸€ä¸ªä¸ªåç¨‹å‡½æ•°ï¼Œæ€æ ·æ‰èƒ½å¹¶å‘çš„è¿è¡Œ ğŸ¤” ï¼Ÿ asyncio æä¾›äº†ç›¸åº”çš„ä¸¤ä¸ªæ¥å£ï¼šasyncio.gather å’Œ asyncio.wait æ¥æ”¯æŒ: async def c1(): await asyncio.sleep(1) print(&amp;#39;c1 done&amp;#39;) return True async def c2(): await asyncio.sleep(2) print(&amp;#39;c2 done&amp;#39;) return True async def c12_by_gather(): await asyncio.gather(c1(), c2()) async def c12_by_awit(): await asyncio.wait([c1(), c2()]) In [23]: asyncio.run(c12_by_gather()) c1 done c2 done In [24]: asyncio.run(c12_by_awit()) c1 done c2 done å…¶å®ƒ ä¸Šé¢æˆ‘ä»¬ä»‹ç»äº† PEP 492 coroutine çš„åŸºç¡€ä½¿ç”¨ï¼ŒåŒæ—¶ PEP 492 ä¹Ÿç›¸åº”æå‡ºäº†åŸºäº async with å’Œ async for è¡¨è¾¾å¼çš„å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨(asynchronous context manager)å’Œå¼‚æ­¥è¿­ä»£å™¨(asynchronous iterator)ã€‚ ä¸‹é¢çš„ä»‹ç»çš„ç¤ºä¾‹å°†åŸºäº Python å¯è¿­ä»£å¯¹è±¡, è¿­ä»£å™¨å’Œç”Ÿæˆå™¨ é‡Œçš„ç¤ºä¾‹å±•å¼€ï¼Œå»ºè®®æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥å…ˆçœ‹ä¸‹è¿™ç¯‡æ–‡ç« ã€‚ å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ åœ¨ Python ä¸­ï¼Œæˆ‘ä»¬å¸¸ä¼šé€šè¿‡å®ç° __enter__() å’Œ __exit__() æ–¹æ³•æ¥å®ç°ä¸€ä¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼š In [1]: class ContextManager: ...: ...: def __enter__(self): ...: print(&amp;#39;enter...&amp;#39;) ...: ...: def __exit__(slef, exc_type, exc_val, exc_tb): ...: print(&amp;#39;exit...&amp;#39;) ...: In [2]: with ContextManager(): ...: print(&amp;#39;Do something...&amp;#39;) ...: enter... Do something... exit... åŒæ ·çš„ï¼Œåœ¨å¼‚æ­¥ç¼–ç¨‹æ—¶æˆ‘ä»¬å¯ä»¥é€šè¿‡å®ç° __aenter__() å’Œ __aexit__() æ–¹æ³•æ¥å®ç°ä¸€ä¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œå¹¶é€šè¿‡ async with è¡¨è¾¾å¼æ¥ä½¿ç”¨ã€‚ In [1]: class AsyncContextManager: ...: ...: async def __aenter__(self): ...: print(&amp;#39;async enter...&amp;#39;) ...: ...: async def __aexit__(slef, exc_type, exc_val, exc_tb): ...: print(&amp;#39;async exit...&amp;#39;) ...: In [2]: async with AsyncContextManager(): ...: print(&amp;#39;Do something...&amp;#39;) ...: async enter... Do something... async exit... å¼‚æ­¥è¿­ä»£ åœ¨ä¹‹å‰çš„æ–‡ç«  Python å¯è¿­ä»£å¯¹è±¡, è¿­ä»£å™¨å’Œç”Ÿæˆå™¨ ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†é€šè¿‡å®ç° __iter__() æ–¹æ³•æ¥å®ç°ä¸€ä¸ªå¯è¿­ä»£å¯¹è±¡ï¼Œé€šè¿‡å®ç°è¿­ä»£å™¨åè®® __iter__() å’Œ __next__() æ–¹æ³•æ¥å®ç°ä¸€ä¸ªè¿­ä»£å™¨å¯¹è±¡ã€‚ä¸‹é¢æˆ‘ä»¬æ”¹é€ ä¸‹ä¹‹å‰çš„ä¾‹å­ï¼Œå®ç°ä¸€ä¸ªå¼‚æ­¥çš„ç‰ˆæœ¬ã€‚ class AsyncLinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.findall(self.PATTERN, text) def __aiter__(self): return AsyncLinkIiterator(self.links) class AsyncLinkIiterator: def __init__(self, links): self.links = links self.index = 0 async def _gen_link(self): try: link = self.links[self.index] self.index += 1 except IndexError: link = None return link def __aiter__(self): return self async def __anext__(self): link = await self._gen_link() if link is None: raise StopAsyncIteration return link In [7]: async for s in AsyncLinkFinder(TEXT): ...: print(s) https://blog.python.org http://feedproxy.google.com/~r/PythonSoftwareFoundationNew/~3/T3r7qZxo-xg/python-software-foundation-fellow.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/lE0u-5MIUQc/why-sponsor-pycon-2020.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/jAMRqiPhWSs/seeking-developers-for-paid-contract.html ä¾‹å­ä¸­å®ç°äº† __aiter__() æ–¹æ³•çš„ AsyncLinkFinder å°±æ˜¯ä¸€ä¸ªå¼‚æ­¥å¯è¿­ä»£å¯¹è±¡ï¼Œ__aiter__() æ–¹æ³•è¿”å›çš„å¿…é¡»æ˜¯ä¸€ä¸ªå¼‚æ­¥è¿­ä»£å™¨ï¼Œå¦‚ AsyncLinkIiteratorã€‚å¼‚æ­¥è¿­ä»£å™¨å¿…é¡»åŒæ—¶å®ç° __aiter__() å’Œ __anext__() æ–¹æ³•ã€‚ä¸€ä¸ªä¸åŒçš„ç‚¹æ˜¯ï¼Œå¼‚æ­¥è¿­ä»£ä¸­ï¼Œå½“è¿­ä»£å™¨è€—å°½æ—¶ï¼Œéœ€è¦å¼•å‘ä¸€ä¸ª StopAsyncIteration è€Œä¸æ˜¯ StopIterationã€‚ åŒæ ·çš„ï¼Œæˆ‘ä»¬ä¹Ÿå®ç°ä¸€ä¸ªå¼‚æ­¥ç”Ÿæˆå™¨ç‰ˆæœ¬çš„ï¼š class LinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.finditer(self.PATTERN, text) async def __aiter__(self): return (link.group() for link in self.links) æ³¨ â‘  å…³äºè¿­ä»£å™¨çš„ä»‹ç»å¯é˜…è¯» Python å¯è¿­ä»£å¯¹è±¡, è¿­ä»£å™¨å’Œç”Ÿæˆå™¨ã€‚ â‘¡ å…³äºç¤ºä¾‹ä¸­ __slots__ çš„ä»‹ç»è¯·æŸ¥çœ‹ ç†è§£ Python ç±»å±æ€§ä¹‹ __slots__ã€‚ å‚è€ƒ PEP 492: Coroutines with async and await syntax PEP 342: Coroutines via Enhanced Generators</description>
    </item>
    
  </channel>
</rss>