<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础原理 on feileo</title>
    <link>https://at7h.com/tags/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</link>
    <description>Recent content in 基础原理 on feileo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 17 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://at7h.com/tags/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>走进 Python 类的内部</title>
      <link>https://at7h.com/posts/py-classes/</link>
      <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/py-classes/</guid>
      <description>这篇文章和大家一起聊一聊 Python 3.8 中类和对象背后的一些概念和实现原理，主要尝试解释 Python 类和对象属性的存储，函数和方法，描述器，对象内存占用的优化支持，以及继承与属性查找等相关问题。 让我们从一个简单的例子开始： class Employee: outsource = False def __init__(self, department, name): self.department = department self.name = name @property def inservice(self): return self.department is not None def __repr__(self): return f&amp;#34;&amp;lt;Employee: {self.department}-{self.name}&amp;gt;&amp;#34; employee = Employee(&amp;#39;IT&amp;#39;, &amp;#39;bobo&amp;#39;) employee 对象是 Employee 类的一个实例，它有两个属性 department 和 name，其值属于该实例。outsource 是类属性，所有者是类，该类的所有实例对象共享此属性值，这跟其他面向对象语言一致。 更改类变量会影响到该类的所有实例对象： &amp;gt;&amp;gt;&amp;gt; e1 = Employee(&amp;#39;IT&amp;#39;, &amp;#39;bobo&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e2 = Employee(&amp;#39;HR&amp;#39;, &amp;#39;cici&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e1.outsource, e2.outsource (False, False) &amp;gt;&amp;gt;&amp;gt; Employee.outsource = True &amp;gt;&amp;gt;&amp;gt; e1.outsource, e2.outsource &amp;gt;&amp;gt;&amp;gt; (True, True) 这仅限于从类更改，当我们从实例更改类变量时： &amp;gt;&amp;gt;&amp;gt; e1 = Employee(&amp;#39;IT&amp;#39;, &amp;#39;bobo&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e2 = Employee(&amp;#39;HR&amp;#39;, &amp;#39;cici&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e1.outsource, e2.outsource (False, False) &amp;gt;&amp;gt;&amp;gt; e1.outsource = True &amp;gt;&amp;gt;&amp;gt; e1.outsource, e2.outsource (True, False) 是的，当你试图从实例对象修改类变量时，Python 不会更改该类的类变量值，而是创建一个同名的实例属性，这是非常正确且安全的。在搜索属性值时，实例变量会优先于类变量，这将在继承与属性查找一节中详细解释。 值得特别注意的是，当类变量的类型是可变类型时，你是从实例对象中更改的它们的： &amp;gt;&amp;gt;&amp;gt; class S: ... L = [1, 2] ... &amp;gt;&amp;gt;&amp;gt; s1, s2 = S(), S() &amp;gt;&amp;gt;&amp;gt; s1.L, s2.L ([1, 2], [1, 2]) &amp;gt;&amp;gt;&amp;gt; t1.L.append(3) &amp;gt;&amp;gt;&amp;gt; t1.L, s2.L ([1, 2, 3], [1, 2, 3]) 好的实践方式是应当尽量的避免这样的设计。 属性的存储 本小节我们一起来看看 Python 中的类属性、方法及实例属性是如何关联存储的。 实例属性 在 Python 中，所有实例属性都存储在 __dict__ 字典中，这就是一个常规的 dict，对于实例属性的维护即是从该字典中获取和修改，它对开发者是完全开放的。 &amp;gt;&amp;gt;&amp;gt; e = Employee(&amp;#39;IT&amp;#39;, &amp;#39;bobo&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e.__dict__ {&amp;#39;department&amp;#39;: &amp;#39;IT&amp;#39;, &amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;} &amp;gt;&amp;gt;&amp;gt; type(e.__dict__) dict &amp;gt;&amp;gt;&amp;gt; e.name is e.__dict__[&amp;#39;name&amp;#39;] True &amp;gt;&amp;gt;&amp;gt; e.__dict__[&amp;#39;department&amp;#39;] = &amp;#39;HR&amp;#39; &amp;gt;&amp;gt;&amp;gt; e.department &amp;#39;HR&amp;#39; 正因为实例属性是采用字典来存储，所以任何时候我们都可以方便的给对象添加或删除字段： &amp;gt;&amp;gt;&amp;gt; e.age = 30 # 并没有定义 age 属性 &amp;gt;&amp;gt;&amp;gt; e.age 30 &amp;gt;&amp;gt;&amp;gt; e.__dict__ {&amp;#39;department&amp;#39;: &amp;#39;IT&amp;#39;, &amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;, &amp;#39;age&amp;#39;: 30} &amp;gt;&amp;gt;&amp;gt; del e.age &amp;gt;&amp;gt;&amp;gt; e.__dict__ {&amp;#39;department&amp;#39;: &amp;#39;IT&amp;#39;, &amp;#39;name&amp;#39;: &amp;#39;d&amp;#39;} 我们也可以从字典中实例化一个对象，或者通过保存实例的 __dict__ 来恢复实例。 &amp;gt;&amp;gt;&amp;gt; def new_employee_from(d): ... instance = object.__new__(Employee) ... instance.__dict__.update(d) ... return instance ... &amp;gt;&amp;gt;&amp;gt; e1 = new_employee_from({&amp;#39;department&amp;#39;: &amp;#39;IT&amp;#39;, &amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;}) &amp;gt;&amp;gt;&amp;gt; e1 &amp;lt;Employee: IT-bobo&amp;gt; &amp;gt;&amp;gt;&amp;gt; state = e1.__dict__.copy() &amp;gt;&amp;gt;&amp;gt; del e1 &amp;gt;&amp;gt;&amp;gt; e2 = new_employee_from(state) &amp;gt;&amp;gt;&amp;gt; e2 &amp;gt;&amp;gt;&amp;gt; &amp;lt;Employee: IT-bobo&amp;gt; 因为 __dict__ 的完全开放，所以我们可以向其中添加任何 immutable 类型的 key，比如数字： &amp;gt;&amp;gt;&amp;gt; e.__dict__[1] = 1 &amp;gt;&amp;gt;&amp;gt; e.__dict__ {&amp;#39;department&amp;#39;: &amp;#39;IT&amp;#39;, &amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;, 1: 1} 这些非字符串的字段是我们无法通过实例对象访问的，为了确保不会出现这样的情况，除非必要的情况下，一般最好不要直接对 __dict__ 进行写操作，甚至不要直接操作 __dict__。 所以有一种说法是 Python is a &amp;ldquo;consenting adults language&amp;rdquo;。 这种动态的实现使得我们的代码非常灵活，很多时候非常的便利，但这也付出了存储和性能上的开销。所以 Python 也提供了另外一种机制(__slots__)来放弃使用 __dict__，以节约内存，提高性能，详见 __slots__ 一节。 类属性 同样的，类属性也在存储在类的 __dict__ 字典中： &amp;gt;&amp;gt;&amp;gt; Employee.__dict__ mappingproxy({&amp;#39;__module__&amp;#39;: &amp;#39;__main__&amp;#39;, &amp;#39;outsource&amp;#39;: True, &amp;#39;__init__&amp;#39;: &amp;lt;function __main__.Employee.__init__(self, department, name)&amp;gt;, &amp;#39;inservice&amp;#39;: &amp;lt;property at 0x108419ea0&amp;gt;, &amp;#39;__repr__&amp;#39;: &amp;lt;function __main__.Employee.__repr__(self)&amp;gt;, &amp;#39;__str__&amp;#39;: &amp;lt;function __main__.Employee.__str__(self)&amp;gt;, &amp;#39;__dict__&amp;#39;: &amp;lt;attribute &amp;#39;__dict__&amp;#39; of &amp;#39;Employee&amp;#39; objects&amp;gt;, &amp;#39;__weakref__&amp;#39;: &amp;lt;attribute &amp;#39;__weakref__&amp;#39; of &amp;#39;Employee&amp;#39; objects&amp;gt;, &amp;#39;__doc__&amp;#39;: None} &amp;gt;&amp;gt;&amp;gt; type(Employee.__dict__) mappingproxy 与实例字典的『开放』不同，类属性使用的字典是一个 MappingProxyType 对象，它是一个不能 setattr 的字典。这意味着它对开发者是只读的，其目的正是为了保证类属性的键都是字符串，以简化和加快新型类属性的查找和 __mro__ 的搜索逻辑。 &amp;gt;&amp;gt;&amp;gt; Employee.__dict__[&amp;#39;outsource&amp;#39;] = False TypeError: &amp;#39;mappingproxy&amp;#39; object does not support item assignment 因为所有的方法都归属于一个类，所以它们也存储在类的字典中，从上面的例子中可以看到已有的 __init__ 和 __repr__ 方法。我们可以再添加几个来验证： class Employee: # ... @staticmethod def soo(): pass @classmethod def coo(cls): pass def foo(self): pass &amp;gt;&amp;gt;&amp;gt; Employee.__dict__ mappingproxy({&amp;#39;__module__&amp;#39;: &amp;#39;__main__&amp;#39;, &amp;#39;outsource&amp;#39;: False, &amp;#39;__init__&amp;#39;: &amp;lt;function __main__.Employee.__init__(self, department, name)&amp;gt;, &amp;#39;__repr__&amp;#39;: &amp;lt;function __main__.Employee.__repr__(self)&amp;gt;, &amp;#39;inservice&amp;#39;: &amp;lt;property at 0x108419ea0&amp;gt;, &amp;#39;soo&amp;#39;: &amp;lt;staticmethod at 0x1066ce588&amp;gt;, &amp;#39;coo&amp;#39;: &amp;lt;classmethod at 0x1066ce828&amp;gt;, &amp;#39;foo&amp;#39;: &amp;lt;function __main__.Employee.foo(self)&amp;gt;, &amp;#39;__dict__&amp;#39;: &amp;lt;attribute &amp;#39;__dict__&amp;#39; of &amp;#39;Employee&amp;#39; objects&amp;gt;, &amp;#39;__weakref__&amp;#39;: &amp;lt;attribute &amp;#39;__weakref__&amp;#39; of &amp;#39;Employee&amp;#39; objects&amp;gt;, &amp;#39;__doc__&amp;#39;: None}) 继承与属性查找 目前为止，我们已经知道，所有的属性和方法都存储在两个 __dict__ 字典中，现在我们来看看 Python 是如何进行属性查找的。 Python 3 中，所有类都隐式的继承自 object，所以总会有一个继承关系，而且 Python 是支持多继承的： &amp;gt;&amp;gt;&amp;gt; class A: ... pass ... &amp;gt;&amp;gt;&amp;gt; class B: ... pass ... &amp;gt;&amp;gt;&amp;gt; class C(B): ... pass ... &amp;gt;&amp;gt;&amp;gt; class D(A, C): ... pass ... &amp;gt;&amp;gt;&amp;gt; D.mro() [&amp;lt;class &amp;#39;__main__.D&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.A&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.C&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;] mro() 是一个特殊的方法，它返回类的线性解析顺序。 属性访问的默认行为是从对象的字典中获取、设置或删除属性，例如对于 e.f 的查找简单描述是: e.f 的查找顺序会从 e.__dict__[&#39;f&#39;] 开始，然后是 type(e).__dict__[&#39;f&#39;]，接下来依次查找 type(e) 的基类（__mro__ 顺序，不包括元类）。 如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而发起调用描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。 所以，要理解查找的顺序，你必须要先了解描述器协议。 简单总结，有两种描述器类型：数据描述器和和非数据描述器。 如果一个对象除了定义 __get__() 之外还定义了 __set__() 或 __delete__()，则它会被视为数据描述器。仅定义了 __get__() 的描述器称为非数据描述器（它们通常被用于方法，但也可以有其他用途) 由于函数只实现 __get__，所以它们是非数据描述器。 Python 的对象属性查找顺序如下： 类和父类字典的数据描述器 实例字典 类和父类字典中的非数据描述器 请记住，无论你的类有多少个继承级别，该类对象的实例字典总是存储了所有的实例变量，这也是 super 的意义之一。 下面我们尝试用伪代码来描述查找顺序： def get_attribute(obj, name): class_definition = obj.__class__ descriptor = None for cls in class_definition.mro(): if name in cls.__dict__: descriptor = cls.__dict__[name] break if hasattr(descriptor, &amp;#39;__set__&amp;#39;): return descriptor, &amp;#39;data descriptor&amp;#39; if name in obj.__dict__: return obj.__dict__[name], &amp;#39;instance attribute&amp;#39; if descriptor is not None: return descriptor, &amp;#39;non-data descriptor&amp;#39; else: raise AttributeError &amp;gt;&amp;gt;&amp;gt; e = Employee(&amp;#39;IT&amp;#39;, &amp;#39;bobo&amp;#39;) &amp;gt;&amp;gt;&amp;gt; get_attribute(e, &amp;#39;outsource&amp;#39;) (False, &amp;#39;non-data descriptor&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e.outsource = True &amp;gt;&amp;gt;&amp;gt; get_attribute(e, &amp;#39;outsource&amp;#39;) (True, &amp;#39;instance attribute&amp;#39;) &amp;gt;&amp;gt;&amp;gt; get_attribute(e, &amp;#39;name&amp;#39;) (&amp;#39;bobo&amp;#39;, &amp;#39;instance attribute&amp;#39;) &amp;gt;&amp;gt;&amp;gt; get_attribute(e, &amp;#39;inservice&amp;#39;) (&amp;lt;property at 0x10c966d10&amp;gt;, &amp;#39;data descriptor&amp;#39;) &amp;gt;&amp;gt;&amp;gt; get_attribute(e, &amp;#39;foo&amp;#39;) (&amp;lt;function __main__.Employee.foo(self)&amp;gt;, &amp;#39;non-data descriptor&amp;#39;) 由于这样的优先级顺序，所以实例是不能重载类的数据描述器属性的，比如 property 属性： &amp;gt;&amp;gt;&amp;gt; class Manager(Employee): ... def __init__(self, *arg): ... self.inservice = True ... super().__init__(*arg) ... &amp;gt;&amp;gt;&amp;gt; m = Manager(&amp;#34;HR&amp;#34;, &amp;#34;cici&amp;#34;) AttributeError: can&amp;#39;t set attribute 发起描述器调用 上面讲到，在查找属性时，如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而发起描述器方法调用。 描述器的作用就是绑定对象属性，我们假设 a 是一个实现了描述器协议的对象，对 e.a 发起描述器调用有以下几种情况： 直接调用：用户级的代码直接调用e.__get__(a)，不常用 实例绑定：绑定到一个实例，e.a 会被转换为调用: type(e).__dict__[&#39;a&#39;].__get__(e, type(e)) 类绑定：绑定到一个类，E.a 会被转换为调用: E.__dict__[&#39;a&#39;].__get__(None, E) 在继承关系中进行绑定时，会根据以上情况和 __mro__ 顺序来发起链式调用。 函数与方法 我们知道方法是属于特定类的函数，唯一的不同(如果可以算是不同的话)是方法的第一个参数往往是为类或实例对象保留的，在 Python 中，我们约定为 cls 或 self, 当然你也可以取任何名字如 this(只是最好不要这样做)。 上一节我们知道，函数实现了 __get__() 方法的对象，所以它们是非数据描述器。在 Python 访问(调用)方法支持中正是通过调用 __get__() 将调用的函数绑定成方法的。 在纯 Python 中，它的工作方式如下(示例来自描述器使用指南): class Function: def __get__(self, obj, objtype=None): if obj is None: return self return types.MethodType(self, obj) # 将函数绑定为方法 在 Python 2 中，有两种方法: unbound method 和 bound method，在 Python 3 中只有后者。 bound method 与它们绑定的类或实例数据相关联： &amp;gt;&amp;gt;&amp;gt; Employee.coo &amp;lt;bound method Employee.coo of &amp;lt;class &amp;#39;__main__.Employee&amp;#39;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; Employee.foo &amp;lt;function __main__.Employee.foo(self)&amp;gt; &amp;gt;&amp;gt;&amp;gt; e = Employee(&amp;#39;IT&amp;#39;, &amp;#39;bobo&amp;#39;) &amp;gt;&amp;gt;&amp;gt; e.foo &amp;lt;bound method Employee.foo of &amp;lt;Employee: IT-bobo&amp;gt;&amp;gt; 我们可以从方法来访问实例与类： &amp;gt;&amp;gt;&amp;gt; e.foo.__self__ &amp;lt;Employee: IT-bobo&amp;gt; &amp;gt;&amp;gt;&amp;gt; e.foo.__self__.__class__ __main__.Employee 借助描述符协议，我们可以在类的外部作用域手动绑定一个函数到方法，以访问类或实例中的数据，我将以这个示例来解释当你的对象访问(调用)类字典中存储的函数时将其绑定成方法(执行)的过程： 现有以下函数： &amp;gt;&amp;gt;&amp;gt; def f1(self): ... if isinstance(self, type): ... return self.outsource ... return self.name ... &amp;gt;&amp;gt;&amp;gt; bound_f1 = f1.__get__(e, Employee) # or bound_f1 = f1.__get__(e) &amp;gt;&amp;gt;&amp;gt; bound_f1 &amp;lt;bound method f1 of &amp;lt;Employee: IT-bobo&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; bound_f1.__self__ &amp;lt;Employee: IT-bobo&amp;gt; &amp;gt;&amp;gt;&amp;gt; bound_f1() &amp;#39;bobo&amp;#39; 总结一下：当我们调用 e.foo() 时，首先从 Employee.__dict__[&#39;foo&#39;] 中得到 foo 函数，在调用该函数的 foo 方法 foo.__get__(e) 将其转换成方法，然后执行 foo() 获得结果。这就完成了 e.foo() -&amp;gt; f(e) 的过程。 如果你对我的解释感到疑惑，我建议你可以阅读官方的描述器使用指南以进一步了解描述器协议，在该文的函数和方法和静态方法和类方法一节中详细了解函数绑定为方法的过程。同时在 Python 类一文的方法对象一节中也有相关的解释。 __slots__ Python 的对象属性值都是采用字典存储的，当我们处理数成千上万甚至更多的实例时，内存消耗可能是一个问题，因为字典哈希表的实现，总是为每个实例创建了大量的内存。所以 Python 提供了一种 __slots__ 的方式来禁用实例使用 __dict__，以优化此问题。 通过 __slots__ 来指定属性后，会将属性的存储从实例的 __dict__ 改为类的 __dict__ 中： class Test: __slots__ = (&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;) def __init__(self, a, b): self.a = a self.b = b &amp;gt;&amp;gt;&amp;gt; t = Test(1, 2) &amp;gt;&amp;gt;&amp;gt; t.__dict__ AttributeError: &amp;#39;Test&amp;#39; object has no attribute &amp;#39;__dict__&amp;#39; &amp;gt;&amp;gt;&amp;gt; Test.__dict__ mappingproxy({&amp;#39;__module__&amp;#39;: &amp;#39;__main__&amp;#39;, &amp;#39;__slots__&amp;#39;: (&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;), &amp;#39;__init__&amp;#39;: &amp;lt;function __main__.Test.__init__(self, a, b)&amp;gt;, &amp;#39;a&amp;#39;: &amp;lt;member &amp;#39;a&amp;#39; of &amp;#39;Test&amp;#39; objects&amp;gt;, &amp;#39;b&amp;#39;: &amp;lt;member &amp;#39;b&amp;#39; of &amp;#39;Test&amp;#39; objects&amp;gt;, &amp;#39;__doc__&amp;#39;: None}) 关于 __slots__ 我之前专门写过一篇文章分享过，感兴趣的同学请移步理解 Python 类属性 __slots__ 一文。 补充 __getattribute__ 和 __getattr__ 也许你还有疑问，那函数的 __get__ 方法是怎么被调用的呢，这中间过程是什么样的？ 在 Python 中 一切皆对象，所有对象都有一个默认的方法 __getattribute__(self, name)。 该方法会在我们使用 . 访问 obj 的属性时会自动调用，为了防止递归调用，它总是实现为从基类 object 中获取 object.__getattribute__(self, name), 该方法大部分情况下会默认从 self 的 __dict__ 字典中查找 name(除了特殊方法的查找)。 话外：如果该类还实现了 __getattr__，则只有 __getattribute__ 显式地调用或是引发了 AttributeError 异常后才会被调用。__getattr__ 由开发者自己实现，应当返回属性值或引发 AttributeError 异常。 而描述器正是由 __getattribute__() 方法调用，其大致逻辑为： def __getattribute__(self, key): v = object.__getattribute__(self, key) if hasattr(v, &amp;#39;__get__&amp;#39;): return v.__get__(self) return v 请注意：重写 __getattribute__() 会阻止描述器的自动调用。 函数属性 函数也是 Python function 对象，所以一样，它也具有任意属性，这有时候是有用的，比如实现一个简单的函数调用跟踪装饰器： def calltracker(func): @wraps(func) def wrapper(*args, **kwargs): wrapper.calls += 1 return func(*args, **kwargs) wrapper.calls = 0 return wrapper @calltracker def f(): return &amp;#39;f called&amp;#39; &amp;gt;&amp;gt;&amp;gt; f.calls 0 &amp;gt;&amp;gt;&amp;gt; f() &amp;#39;f called&amp;#39; &amp;gt;&amp;gt;&amp;gt; f.calls 1 参考 HowFunctionsToMethods Descriptor HowTo Guide Python Data model Understanding internals of Python classes</description>
    </item>
    
    <item>
      <title>GC 机制探究之 Python 篇</title>
      <link>https://at7h.com/posts/gc-in-py/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/gc-in-py/</guid>
      <description>本文主要讨论垃圾回收（Garbage Collection）机制在 Python 3.7 中是如何工作的。 不同的 Python 解释器有各自 GC 的实现方式，比如 Jython 跑在 JVM 上，采用了标准的 Java GC，Pypy 的 GC 使用了标记-清除(Mark and Sweep)算法，它比 CPython 的更加复杂并且有着一些额外的优化。 本文讨论主流的 CPython 解释器。 通常，你在使用一些高级语言（Python、Golang、Java 等）编写代码的时候，一般无需关心内存管理的问题，当对象不再需要的时候，GC 会自动的把它们回收。但是了解 GC 的工作原理可以帮助你编写更好、更快的程序，帮助你排查一些复杂的内存问题。 常见 GC 算法 业界常见的比较知名的垃圾回收算法有： 1. 引用计数(Reference counting)：对每个对象维护一个引用计数，当引用计数器为零时回收该对象。代表语言如 Python。 优点：简单有效，对象可以被很快回收，不会出现内存耗尽或达到某个阀值时才回收。 缺点：很明显，对每个对象维护引用计数有一定代价，而且致命的是无法处理循环引用的问题。 2. 标记-清除(Mark and Sweep)：为解决循环引用问题而提出，算法从根对象开始遍历程序所有对象的引用，可达的对象被标记，最终没被标记的对象被删除回收。代表语言如 Golang(三色标记)。 优点：解决循环引用的问题，并且在算法执行期间不会产生额外的开销。 缺点：需要 STW(stop the world)，即执行期间需要程序暂停，并且容易在经过多次『标记-清除』循环后导致内存碎片化。 3. 停止-复制(Stop-and-Copy) ：与标记-清除算法类似，差异在于如何处理这些可达的存活对象。该算法将整个堆空间被切分活动区和空闲区，垃圾收集时将所有的可达的存活对象复制到另一区，原本半区的就可以被回收，程序会在新的活动区中分配内存。 优点：运行高效且不容易产生内存碎片，基本解决了标记-清除内存碎片化的问题。 缺点：需要 STW，收集器必须复制所有的活动对象，这增加了程序等待时间，并且在同一时间内只能使用整个内存空间的一半。 3. 标记-压缩(Mark-and-Compact) ：标记阶段与标记-清除算法相同，压缩（整理）阶段不是直接清理，而是让所有的对象都向一端移动，按顺序排放更新对应的指针，然后清理掉端边界以外的内存。 优点：避免了标记-清除的碎片化问题，同时也避免了停止复制算法的内存空间减半问题。 缺点：需要 STW，低效，因为增加了 copy 和更新指针的过程。 5. 分代收集(Generational Collection)：与其说是一种新算法不如说是一种优化策略，目前很流行。算法按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，从而区别不同的回收算法策略和频率，让各算法充分发挥优势。代表语言如 Java。 优点：可结合其他检测算法，回收性能好。 缺点：算法比较复杂。 没有绝对好和坏的解决方案，在真正语言实现中一般都是几种算法结合使用，下面主要来探讨 Python 中的垃圾回收策略。 GC in Python 在 Python 中，一切皆对象，知道它们什么时候被分配内存很容易，当你需要的时候你可以很容易创建一个新的对象。但回收确是比较复杂的一件事，需要确定你的对象确实是不再需要了，过早的清理可能会导致程序崩溃，如果不予以释放，则会造成内存泄露。 垃圾回收的主要任务就是确定哪些对象可以被收回，并选择一个最佳的时间来释放它们占用的内存。标准的 CPython GC 有两个组件： 引用计数收集器(reference counting collector)：主要的、基础模块、不可控，不能禁用。 分代垃圾收集器(generational garbage collector)：辅助的、可以控制，即 gc module。 CPython 的垃圾回收主要是通过引用计数技术，引用计数是非常有效和简单的，但它不能检测循环引用(reference cycles)，因此 CPython 又设计了一个分代垃圾收集器作为补充算法来专门处理循环引用的问题.因它只处理循环引用，也被称为分代循环(generational cyclic) GC。Python 中常说的 GC 其实就是它，其默认情况下是启用的，你可以手动触发和禁用它。 CPython GC 的策略是： 对每个对象维护引用计数 通过一个辅助算法来定期检测循环引用，释放无用对象 引入分代策略来优化此检测，提高性能 引用计数 引用计数是一种简单的技术，当程序中没有对该对象的引用时，将其释放。 Python 中的每个变量都是对真实对象的引用（指针），为了跟踪引用，每个对象（包括整数、字符串）都会有一个引用计数的额外字段，该字段会一直维护，在创建或删除指向该对象的引用时会增加或减少。有关详细说明，可以参见 Objects, Types and Reference Counts 部分。 导致引用计数增加主要有： 赋值运算符 参数传递 将对象（作为元素）append 到容器中 如果对象的引用计数达到零，CPython 会自动调用对象特定的内存释放函数。如果一个对象包含对其他对象的引用，则它们的引用计数也会自动减少，因此，可以依次释放其他对象。例如，当删除 List 时，所有 List 元素的引用计数都会减少。如果存在另一个变量引用了 List 中的某个项目，则该元素不会被释放。 在 Python 中，全局变量会一直存在直到 Python 进程结束为止。因此，由全局变量引用的对象的引用计数永远不会降为零，所有全局变量都存储在字典中，你可以通过调用 globals() 函数来获取它们。 在某一个『块』中定义的局部变量，如 function、class 或 with（context&amp;rsquo;s enter/exit) 语句具有局部作用域，当解释器从该块中退出时，会释放在该块内部创建的局部变量及其引用。在 Python 中，用的最多的『块』应该就是函数（方法）了，这是大多数垃圾收集发生的地方，同时这也是保持函数功能单一一个原因吧。 在 Python 中，你始终可以使用 sys.getrefcount 函数检查对象引用的数量。来看一个简单的示例： In [1]: import sys In [2]: sys.getrefcount? Docstring: getrefcount(object) -&amp;gt; integer Return the reference count of object. The count returned is generally one higher than you might expect, because it includes the (temporary) reference as an argument to getrefcount(). Type: builtin_function_or_method In [3]: l = [] In [4]: sys.getrefcount(l) Out[4]: 2 # 变量 l 和 getrefcount 中的临时变量 In [5]: def f(a): ...: print(&amp;#34;Here reference count is:&amp;#34;, sys.getrefcount(a)) ...: In [6]: f(l) Here reference count is: 4 In [7]: sys.getrefcount(l) Out[7]: 2 # 函数作用域的被销毁 有时我们需要刻意的手动删除某一变量，可以使用 del 语句（其删除变量及其引用，而不是对象本身），这在 REPL 环境（Jupyter notebooks，IPython 等）工作时通常很有用，因为所有变量都是全局范围的。 个人觉得，CPython 使用引用计数主要是历史原因，关于这种技术的弱点很多争论。很多人觉得现代垃圾收集算法可以更高效，无需引用计数，引用计数算法有很多问题，例如循环引用，线程锁定以及内存和性能的额外开销。 引用计数应该也是 CPython 无法摆脱 GIL 的原因之一。 循环引用 以下情况会产生循环引用： 对象包含本身的引用 两个对象之间相互引用 为了证明这一点，我们使用 ctypes 模块来跟踪访问对象的内存地址，以展示上面两种情况： In [1]: import gc, ctypes In [2]: gc.disable() In [3]: class Object(ctypes.Structure): ...: _fields_ = [(&amp;#34;refcnt&amp;#34;, ctypes.c_long)] In [4]: l = [] ...: l.append(l) In [5]: lst_address = id(l) In [6]: del l In [7]: object_1 = {} ...: object_2 = {} ...: object_1[&amp;#39;obj2&amp;#39;] = object_2 ...: object_2[&amp;#39;obj1&amp;#39;] = object_1 In [8]: obj_address = id(object_1) In [9]: del object_1, object_2 In [10]: Object.from_address(obj_address).refcnt Out[10]: 1 In [11]: Object.from_address(lst_address).refcnt Out[11]: 1 示例中，del 语句删除了对象的引用，对象被 del 后，我们不能再从 Python 代码中访问这些对象，但它们仍位于内存中。在 Python 2.0 版本以前，它们在程序运行中永远不会被释放。发生这种情况就是因为它们仍然相互引用，并且每个对象的引用计数为 1，感兴趣的同学你可以使用 objgraph 模块来直观地探索这种对象关系。 解决循环引用问题 为了解决循环引用问题，CPython 引入了一种附加的循环引用检测算法来负责处理这样的问题（即自 Python 2.0 开始的 gc 模块）。 那么问题来了，为什么当时不采用上文说的几种传统回收算法（如 Mark and Sweep 或 Stop-and-Copy 等）呢？原因是由于 CPython 扩展模块的工作方式，CPython 永远无法完全确定根集，这样就有可能释放仍然在某个地方有引用的对象，造成程序崩溃。所以最终是在引用计数的基础上，设计了一种可以检测并处理循环引用的算法。 提示：如果你使用搜索引擎搜索过相关的文章，你可能会发现很多文章都讲『Python 是以引用计数为主，标记-清除和分代收集为辅的』收集策略，这是错误的，CPython 中使用的循环引用检测算法（下一节中介绍）并不是标记-清除。使用标记-清除算法的是 Pypy 的 GC。 从概念来说，CPython GC 与上述的几种算法刚好相反，它试图找出不可达的非活动对象，CPython 的开发者认为这将更加安全，即使算法失败，状况也不会比没有垃圾回收的情况更糟（除了浪费的时间和空间）。（就是感觉并不是那么自信 😂 因为循环引用只会在容器类对象中发生，所以只需专注于跟踪所有的容器对象，而且，某些情况下的的容器对象也是不会产生循环引用的（例如只包含不可变对象的字典），所以对于这一类的对象可以进行取消跟踪的优化，取消跟踪一般会在以下两个时机进行： 创建容器对象时 容器对象被收集器检查时 CPython GC 检测算法不会跟踪除元组以外的所有不可变类型，并且作为优化策略，只包含不可变对象的元组和字典也在某些条件下被取消跟踪（其中元组对象是在 GC 过程中决定是否继续跟踪，而字典对象会在创建和 GC 过程中决定）。 我们可以使用 gc.is_tracked(obj) 函数来查看对象的跟踪状态。看几个例子： In [1]: import gc In [2]: gc.is_tracked(1) Out[2]: False In [3]: gc.is_tracked(&amp;#39;s&amp;#39;) Out[3]: False In [4]: gc.is_tracked([]) Out[4]: True In [5]: gc.is_tracked({}) Out[5]: False In [6]: gc.is_tracked({&amp;#39;s1&amp;#39;: 1}) Out[6]: False In [7]: gc.is_tracked({&amp;#39;s1&amp;#39;: []}) Out[7]: True 再来看一个对于字典和元组对象优化的例子: In [8]: d = {&amp;#39;s&amp;#39;: 1} In [9]: gc.is_tracked(d) Out[9]: False In [10]: d[&amp;#39;l&amp;#39;] = [] In [11]: gc.is_tracked(d) Out[11]: True In [12]: t = (1,2,3) In [13]: gc.is_tracked(t) Out[13]: True In [14]: gc.collect() Out[14]: 1015 In [15]: gc.is_tracked(t) Out[15]: False 如何找到循环引用？ 关于 CPython GC 检测循环引用的具体算法逻辑，很难用几段话解释。其主要是维护了两个双向链表，一个包含所有要扫描的对象，另一个包含『暂时』无法访问的所有对象。每个跟踪的容器的对象都有额外的 2+1 个字段，即两个链表指针和一个 gc_refs 字段（初始值为该对象的引用数）。然后寻找循环引用的大致思路是，遍历所有要扫描的容器对象，对于每个容器对象，找到它引用的所有容器对象，并减小其 gc_refs 值，经过完全迭代后，所有引用计数小于 2 的对象都再无法从 Python 访问，因此可以将其收集。 为了完全理解循环引用查找算法，建议感兴趣的同学继续阅读 dentifying reference cycles 一节，或从 CPython 的源码中查看 collect 函数。 使用分代策略优化 CPython GC 有了上述循环引用检测算法，已经可以检测并处理掉程序中循环引用的对象了。接下来就需要关心性能问题了，因为它是定期运行的，所以 CPython 的开发者为此也引入了启发式的分代策略。 为了使收集花费的时间尽可能短 ，CPython GC 将容器对象分为三代，每个新建的对象都归于最年轻第一代，如果该对象在一次垃圾收集中幸存下来，没有被释放，那么它将被移至较高(老)的一代——第二代。与高(老)世代相比，较低(年轻)世代的垃圾收集频率更高，所以大多数临时对象(局部变量等)的创建和清理都是很快的，由此提高了 GC 的性能减少了 GC 的暂停时间。 为了决定何时执行 GC，每个世代都有一个单独的计数器和阈值，计数器存储当代自上次垃圾收集以来分配对象数量减去被释放对象数量的差值，这得益于算法对容器对象的跟踪。每当你分配一个新的容器对象时，CPython 都会检查第一代计数器的值是否超过阈值。如果超过阈值，则在第一代中启动一次 GC(运行上述算法)，那些不会被使用的对象将会被释放，其余被移至第二代，更新计数器，以此类推。 当前各代的计数器值可以通过 gc.get_count() 查看。标准阈值内置为(700, 10, 10)，你可以使用 gc.get_threshold() 查看, 还可以使用 gc.get_threshold 函数进行调整。 此外，你还可以通过 gc.collect(generation=None) 手动触发 GC。 如果你有兴趣，可以继续在 CPython 的源码中查看 collect 函数，以了解更加具体的算法逻辑。 总结 CPython 的大部分垃圾收集是通过引用计数完成的，我们无法对其进行干涉调整，通过辅助的分代 GC 来处理循环引用，其可控，即 gc module。关于性能： 所有对象(包括数字、字符串)都必须实时正确的维护引用计数，这需要额外的内存与 CPU 开销，另外维护容器对象的跟踪字段(也需要额外的内存和 CPU 开销。 WTP 时间其他实现相比相对较少，这得益于引用计数策略(只要没有太多的循环引用)，CPython 并没有对此进行特殊优化，如 Golang 的写屏障(Write Barrier)等。 CPython GC 并没有将所有活动的可达对象拷贝到另一整块内存重新编排，所以还是会造成内存碎片。 提示或建议 1. 如果你可以保证不会出现循环引用，则可以通过 gc.disable 完全禁用 GC，在某些情况下，禁用 GC 并手动 gc.collect() 很有用。 2. 为避免产生循环引用，可考虑使用弱引用 weakref ，weakref.ref 不会增加引用计数，并且当对象只剩弱引用时不会保持其活性（可以被 GC 正常回收），并在对象被释放后安全返回 None。 3. 循环在现实生活中很容易发生。通常，您会在图形，链接列表或结构中遇到它们，在其中需要跟踪对象之间的关系。如果您的程序工作量大且要求低延迟，则需要尽可能避免参考周期。 查找或调试分析循环引用 1. 标准 gc 模块 提供了接口可以帮助调试，例如 gc.set_debug(gc.DEBUG_SAVEALL)，则找到的所有的不可达对象将追加到 gc.garbage 列表中，你可以在其中查看。 2. 当你发现了循环引用的对象后，就可以使用上文中提到的 objgraph 来直观的探索它与其它对象间的关系。 参考 Design of CPython’s Garbage Collector Garbage collection in Python: things you need to know Garbage Collection for Python How does garbage collection in Python work? What are the pros and cons?</description>
    </item>
    
    <item>
      <title>Golang 零值、空值与空结构</title>
      <link>https://at7h.com/posts/go-null/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/go-null/</guid>
      <description>这篇文章我们讨论下有关 Golang 中的零值（The zero value）、空值（nil）和空结构（The empty struct）的相关问题以及它们的一些用途。 零值 零值是指当你声明变量（分配内存）并未显式初始化时，始终为你的变量自动设置一个默认初始值的策略。 首先我们来看看官方有关零值（The zero value）的规范： When storage is allocated for a variable, either through a declaration or a call of new, or when a new value is created, either through a composite literal or a call of make, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: false for booleans, 0 for numeric types, &amp;quot;&amp;rdquo; for strings, and nil for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified. 据此我们可总结出： 对于值类型：布尔类型为 false, 数值类型为 0，字符串为 &amp;quot;&amp;quot;，数组和结构会递归初始化其元素或字段，即其初始值取决于元素或字段。 对于引用类型： 均为 nil，包括指针 pointer，函数 function，接口 interface，切片 slice，管道 channel，映射 map。 通常，为你声明的变量赋予一个默认值是有用的，尤其是为你数组和结构中的元素或字段设置默认值，这是一种保证安全性和正确性的做法，同时也可以让你的代码保持简洁。 比如，下面的示例是我们常用的，结构体 Value 中包含两个 unexported 字段，sync.Mutex 中也有两个 unexported 字段。因为有默认零值，所以我们可以直接使用： package main import &amp;#34;sync&amp;#34; type Value struct { mu sync.Mutex val int } func (v *Value)Incr(){ defer v.mu.Unlock() v.mu.Lock() v.val++ } func main() { var i Value i.Incr() } 因为切片是引用类型的，所以其零值也是 nil： package main import &amp;#34;fmt&amp;#34; import &amp;#34;strings&amp;#34; func main(){ var s []string fmt.Println(s, len(s), cap(s)) // [] 0 0 fmt.Println(s == nil) // true s = append(s, &amp;#34;Hello&amp;#34;) s = append(s, &amp;#34;World&amp;#34;) fmt.Println(strings.Join(s, &amp;#34;, &amp;#34;)) // Hello, World } 下面的情况需要特别注意下，有时候不注意就容易混淆，:= 语法糖是声明并且初始化变量的，所以是一个真正的实例（为其分配了内存地址的），并不是零值 nil： package main import &amp;#34;fmt&amp;#34; import &amp;#34;reflect&amp;#34; func main() { var s1 []string s2 := []string{} // 或者等同于 var s2 = []string{} fmt.Println(s1 == nil) // true fmt.Println(s2 == nil) // false fmt.Println(reflect.DeepEqual(s1, s2)) // false fmt.Println(reflect.DeepEqual(s1, []string{})) // false fmt.Println(reflect.DeepEqual(s2, []string{})) // true } 另外，对于空结构的 nil 是可以调用该类型的方法的，这还可以用来简单地提供默认值： package main import &amp;#34;fmt&amp;#34; const defaultPath = &amp;#34;/usr/bin/&amp;#34; type Config struct { path string } func (c *Config) Path() string { if c == nil { return defaultPath } return c.path } func main() { var c1 *Config var c2 = &amp;amp;Config{ path: &amp;#34;/usr/local/bin/&amp;#34;, } fmt.Println(c1.Path(), c2.Path()) } nil 对于一个刚开始使用 Golang 的开发人员，刚开始接触 nil 应该是使用它来检查错误，大致像这样： func doSomething() error { return nil } func main(){ if doSomething() != nil { return err } } 这是 Golang 惯用的，它鼓励开发人员显式的的将错误作为返回值来处理。现在我们来讨论下这个 nil，在其他语言中也有类似的定义，比如 C、C++、Java 等中的 null，Python 中的 None，但是 Goalng 中的 nil 与它们有着很多区别。 nil 是 Golang 中预先声明的标识符（非关键字保留字），其主要用来表示引用类型的零值（指针，接口，函数，映射，切片和通道），表示它们未初始化的值。 // [src/builtin/builtin.go](https://golang.org/src/builtin/builtin.go#L98) // // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type nil 是 Golang 中唯一没有默认类型的非类型化的值，它不是一个未定义的状态。所以你不能像这样使用它： a := nil // cannot declare variable as untyped nil: a 将一个并没有类型 nil 的值赋给 a 是不对的，编译器不知道它该给 a 分配什么类型。 值得一提的是 Golang 中比较出名的 nil != nil 的问题，我们来看下面的一个例子： var p *int var i interface{} fmt.Println(p) // &amp;lt;nil&amp;gt; fmt.Println(i) // &amp;lt;nil&amp;gt; fmt.Println(p == i) // false Why？为什么同样都是 nil 却不相等呢？ 带着问题，我们再来看一个下面的例子（来自官方 Why is my nil error value not equal to nil）: func Foo() error { var err *MyError = nil if bad() { err = ErrBad } return err } func main() { err := Foo() fmt.Println(err) // &amp;lt;nil&amp;gt; fmt.Println(err == nil) // false } 其罪魁祸首就是 interface，接口相关的实现原理不在本文的讨论范围，后面再具体分享。其大致原理是，接口要确定一个变量需要两个基础属性：Type and Value，下面我们给上面的两段代码加上注释，就明白了： var p *int // (T=*int,V=nil) var i interface{} // (T=nil,V=nil) fmt.Println(p == i) // (T=*int, V=nil) == (T=nil, V=nil) -&amp;gt; false func Foo() error { var err *PathError = nil // (T=*PathError, V=nil) if bad() { err = ErrBad } return err // 这将始终返回 non-nil 错误 } func main() { err := Foo() fmt.Println(err) // &amp;lt;nil&amp;gt; fmt.Println(err == nil) // (T=*PathError, V=nil) == (T=nil, V=nil) -&amp;gt; false } 请注意：为了避免此问题，返回错误时请永远使用 error 接口，并且永远不要初始化可能从函数返回的空错误变量。 我们将上面的例子再改改，看下面的例子： var p *int // (T=*int, V=nil) var i interface{} // (T=nil, V=nil) fmt.Println(p == nil) // true fmt.Println(i == nil) // true i = p fmt.Println(i == nil) // (T=*int, V=nil) == (T=nil, V=nil) -&amp;gt; false 这个问题的实质就是 Go Tour 中的 Interface values with nil underlying values。 示例中 i 可以传递给一个 interface{} 作为输入参数的函数，你只检查 i == nil 是不够的。所以对于接口类型的空指针的判断，有些时候你并不能安全的依靠 v == nil，尽管这种检查的坑很少发生，但这有时候可能会使你的程序崩溃。对此，可以有两种方式解决，你可以分别将类型和值分别和 nil 比较或者使用反射包 reflect。 请记住：如果接口中已存储任何具体值，那么接口将不会是 nil，详见反射定律。 还有就是，也许你也感到困惑，还是上面的例子，为什么下面的类型就可以直接比较并获得准确的结果： var p *int // (T=*int, V=nil) fmt.Println(p == nil) // true 这是因为在进行上面的比较时，因为编译器已经清楚的知道了 p 的类型，所以编译器可以转化为 p == (*int)(nil)。但是对于接口，编译器是没法确定底层类型的，因为它是可以被更改的。 空结构 空结构是没有任何字段的结构类型，例如： type Q struct{} var q struct{} 既然没有任何字段，那它有什么用呢？ 我们知道，一个结构的实例的大小(即所占存储空间的字节数)是由其字段的宽度（size）和对齐（alignment）共同决定的，这样有助于寻址速度，C 语言等都有类似的策略，关于 Golang 的具体策略请阅读 Size and alignment guarantees。 很显然，空结构的占用空间大小为零字节: var q struct {} fmt.Println(unsafe.Sizeof(q)) // 0 由于空结构占用零字节，因此不需要填充对齐，所以由嵌套空结构的空结构也不会占用存储空间。 type Q struct { A struct{} B struct{ C struct{} } } var q Q fmt.Println(unsafe.Sizeof(q)) // 0 由于空结构不占用内存空间，所以我们声明以空结构作为元素的数组或切片，也是不占用空间的（Orthogonality in Go）： var x [1000000000]struct{} fmt.Println(unsafe.Sizeof(x)) // 0 var y = make([]struct{}，1000000000) fmt.Println(unsafe.Sizeof(x))// 24，背后关联数组为 0 对于空结构（或者空数组），其占用的存储大小为零，所以两个不同的零大小的变量在内存中可能具有相同的地址。 来看下面几个示例： var a, b struct{} fmt.Println(&amp;amp;a == &amp;amp;b) // true c := make([]struct{}, 10) d := make([]struct{}, 20) fmt.Println(&amp;amp;c[0] == &amp;amp;d[1]) // true type Q struct{} func (q *Q)addr() { fmt.Printf(&amp;#34;%p\n&amp;#34;, q) } func main() { var a, b Q a.addr() // 0x5af5a60 b.addr() // 0x5af5a60 } e := struct{}{} // 不是零值，一个真正的实例 f := struct{}{} fmt.Println(e == f) // true 请注意，这种相等只是可能，并不是一定的。 比如这个示例，相关问题解释请看这个 issue。 说了半天，你可能会想，貌似这些也没什么实际的用途啊，下面列举两个比较实用的实践用途： 1. 使用 chan struct{} 代替 chan bool 在 goroutines 之间传递信号。使用 bool 容易让人不理解该值，true or false，但是使用 chan struct{} 就很清楚，我们不在乎值，只关心发生的事儿，更容易表达清楚一些。 2. 为了防止 unkeyed 初始化结构，可以添加 _ struct {} 字段： type Q struct { X, Y int _ struct{} 这样一来，使用 Q{X: 1, Y: 1} 可以，但使用 Q{1, 1} 就会出现编译错误：too few values in struct initializer，同时这样也帮助了 go ver 代码检查。 参考 The Go Programming Language Specification Golang Frequently Asked Questions Why Golang Nil Is Not Always Nil? Nil Explained</description>
    </item>
    
    <item>
      <title>理解 Python 类属性 __slots__</title>
      <link>https://at7h.com/posts/py-slots/</link>
      <pubDate>Sun, 19 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/py-slots/</guid>
      <description>网络上有一篇比较有名的文章叫 Saving 9 GB of RAM with Python’s __slots__，文章示例中仅对 Image 类添加了一个 __slots__属性就为服务器节省了 9G 的内存占用。如果有同学看过一些开源的 Python ORM，如 SQLAlchemy, peewee 等，或是看过一些进行 IO 处理的包，你就会在其中发现很多 __slots__ 的身影。 那么，这个 __slots__ 到底是什么？ 下面的解释整理自 Python 官方文档： object.__slots__ 是一个类变量，可赋值为字符串、可迭代对象或由实例使用的变量名构成的字符串序列。其允许我们显式地声明数据成员（如特征属性），为已声明的变量保留空间，并禁止为每个实例创建 __dict__ 和 __weakref__。 举个例子： class X: def __init__(self, a, b): self.a = a self.b = b class Y: __slots__ = (&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;) def __init__(self, a, b): &amp;#34;&amp;#34;&amp;#34; 此时如果你声明一个 __slots__ 中没有的属性，如 self.c = 1 pylint 等就会提示错误： [pylint] [Error] Assigning to attribute &amp;#39;c&amp;#39; not defined in class slots 当然如果你执意要写的话，初始化实例的时候会引发 AttributeError： AttributeError: &amp;#39;Y&amp;#39; object has no attribute &amp;#39;c&amp;#39; &amp;#34;&amp;#34;&amp;#34; self.a = a self.b = b &amp;gt;&amp;gt;&amp;gt; import weakref &amp;gt;&amp;gt;&amp;gt; x = X(7, 8) &amp;gt;&amp;gt;&amp;gt; x.a 7 &amp;gt;&amp;gt;&amp;gt; x.c = 9 &amp;gt;&amp;gt;&amp;gt; x.__dict__ {&amp;#39;a&amp;#39;: 7, &amp;#39;b&amp;#39;: 8, &amp;#39;c&amp;#39;: 9} &amp;gt;&amp;gt;&amp;gt; rx = weakref.ref(x) &amp;gt;&amp;gt;&amp;gt; rx &amp;lt;weakref at 0x107a9e278; to &amp;#39;X&amp;#39; at 0x107618f98&amp;gt; &amp;gt;&amp;gt;&amp;gt; y = Y(7, 8) &amp;gt;&amp;gt;&amp;gt; y.a 7 &amp;gt;&amp;gt;&amp;gt; y.c = 9 AttributeError: &amp;#39;Y&amp;#39; object has no attribute &amp;#39;c&amp;#39; &amp;gt;&amp;gt;&amp;gt; y.__dict__ AttributeError: &amp;#39;Y&amp;#39; object has no attribute &amp;#39;__dict__&amp;#39; &amp;gt;&amp;gt;&amp;gt; ry = weakref.ref(y) TypeError: cannot create weak reference to &amp;#39;Y&amp;#39; object 那使用 __slots__ 到底有什么作用呢？🤔 答案是与 __dict__ 相比，使用 __slots__ 的方式可以显著地节省内存空间，提升属性的查找速度。 之所以会在 ORM 等项目里频繁使用，正是因为这些项目中存在特别多大量创建实例的操作，使用 __slots__ 会明显减少内存的使用，提升速度。并且随着实例数目的增加，其效果会更加显著。 几点疑问 至此，你可能会有几点疑问： 为什么 __slots__ 可以节省内存，提高速度的？ 咋通过 __slots__ 来实现属性的存储与访问的？ 使用了 __slots__ 的类怎么实现动态赋值，如果需要实例弱引用支持怎么搞？ 使用了 __slots__ 的类继承与被继承时的表现？ 针对这几个问题作答： 1. 通常情况下，类实例使用 __dict__来存储其属性数据，好处是允许我们在运行时动态的设置实例属性，然而 dict 哈希表本身的数据结构决定了它需要更多的内存，当创建的实例越多，或者实例的属性越多时，内存的耗费将更加严重。__slots__ 保证了解释器在编译时期就知道这个类具有什么属性，以分配固定的空间来存储已知的属性。 2. 使用 __slots__ 时，会将属性的存储从实例的 __dict__ 改为类的 __dict__ 中： &amp;gt;&amp;gt;&amp;gt; Y.__dict__ mappingproxy({&amp;#39;__module__&amp;#39;: &amp;#39;__main__&amp;#39;, &amp;#39;__slots__&amp;#39;: (&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;), &amp;#39;__init__&amp;#39;: &amp;lt;function __main__.Y.__init__(self, a, b)&amp;gt;, &amp;#39;a&amp;#39;: &amp;lt;member &amp;#39;a&amp;#39; of &amp;#39;Y&amp;#39; objects&amp;gt;, &amp;#39;b&amp;#39;: &amp;lt;member &amp;#39;b&amp;#39; of &amp;#39;Y&amp;#39; objects&amp;gt;, &amp;#39;__doc__&amp;#39;: None}) 属性的访问是通过在类层级上为每个 slot 变量创建和 实现描述器(descriptor) 实现的，该描述器知道属性值在实例列表中的唯一位置。关于描述器与属性的访问在我的 走进 Python 类的内部 一文中均有详细的解释，感兴趣的同学可前去阅读。另外，这篇 how __slots__ are implemented 也许可以帮助你的理解，尽管我看它写于很多年前，但至今依然有借鉴意义。 3.. 怎么实现动态赋值和弱引用支持？答案是：在 __slots__ 中加上 __dict__ 和 __weakref__。 class Y: __slots__ = (&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;__dict__&amp;#39;, &amp;#39;__weakref__&amp;#39;) def __init__(self, a, b): self.a = a self.b = b &amp;gt;&amp;gt;&amp;gt; import weakref &amp;gt;&amp;gt;&amp;gt; y = Y(7, 8) &amp;gt;&amp;gt;&amp;gt; y.a 7 &amp;gt;&amp;gt;&amp;gt; y.b 8 &amp;gt;&amp;gt;&amp;gt; y.c = 9 &amp;gt;&amp;gt;&amp;gt; y.__dict__ {&amp;#39;c&amp;#39;: 9} &amp;gt;&amp;gt;&amp;gt; ry = weakref.ref(y) &amp;gt;&amp;gt;&amp;gt; ry &amp;lt;weakref at 0x107d17d68; to &amp;#39;Y&amp;#39; at 0x107a4d480&amp;gt; 4. 当类继承自一个未定义 __slots__ 的类时，实例的 __dict__ 和 __weakref__ 属性将总是可访问的。 class X: def __init__(self): self.a = 7 class Y(X): __slots__ = (&amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;) def __init__(self): super().__init__() self.b = 8 self.c = 9 &amp;gt;&amp;gt;&amp;gt; y = Y() &amp;gt;&amp;gt;&amp;gt; y.a 7 &amp;gt;&amp;gt;&amp;gt; y.b 8 &amp;gt;&amp;gt;&amp;gt; y.__dict__ {&amp;#39;a&amp;#39;: 7} 5. 在父类中声明的 __slots__ 在其子类中同样可用。不过，子类将会获得 __dict__ 和 __weakref__，除非它们也定义了 __slots__ 。 class X: __slots__=(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;) def __init__(self): self.a = 7 self.b = 8 class Y(X): &amp;#34;&amp;#34;&amp;#34;没有定义 __slots__&amp;#34;&amp;#34;&amp;#34; class Z(X): __slots__ = () &amp;gt;&amp;gt;&amp;gt; y = Y() &amp;gt;&amp;gt;&amp;gt; y.a 7 &amp;gt;&amp;gt;&amp;gt; y.b 8 &amp;gt;&amp;gt;&amp;gt; y.c = 9 &amp;gt;&amp;gt;&amp;gt; y.__dict__ {&amp;#39;c&amp;#39;: 9} &amp;gt;&amp;gt;&amp;gt; z = Z() &amp;gt;&amp;gt;&amp;gt; z.a 7 &amp;gt;&amp;gt;&amp;gt; z.b 8 &amp;gt;&amp;gt;&amp;gt; z.c = 9 AttributeError: &amp;#39;Z&amp;#39; object has no attribute &amp;#39;c&amp;#39; 所以，由 4，5 可知如果需要使用 __slots__, 那么从基类到每个继承的子类都要定义 __slots__。 注意事项 非空的 __slots__ 不适用于派生自「可变长度」内置类型（如 int、str 和 tuple 的派生类）。 __class__ 赋值仅在两个类具有相同的 __slots__ 时才会起作用。 结论 尽管 __slots__ 可以节省内存空间，提高属性的访问速度，但也存在局限性和副作用，并不是用了就是好的，那么到底达到多大的实例规模的类推荐使用呢？这个我也没有具体做过实验，感兴趣的同学可以自行搜索相关论文。在不同的业务场景下，衡量方式也会不同，绝不会是说用 __slots__ 就是好的，必须是需要根据具体场景来决定。</description>
    </item>
    
    <item>
      <title>Python 可迭代对象, 迭代器与生成器</title>
      <link>https://at7h.com/posts/iter/</link>
      <pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/iter/</guid>
      <description>这篇文章主要讨论下 Python 中的容器迭代协议，它的实现统一约定了容器对象的迭代方案，允许我们自定义类对迭代的支持。在 Python 中有很多的协议，比如迭代器协议，描述器协议等等，这些协议比较类似于其他面向对象语言中接口的概念。 本文主要介绍内容为可迭代对象、迭代器和生成器。 可迭代对象(iterable) 以通俗简单的方式来讲，可迭代对象就是能够逐一返回其成员项的对象，其可用于 for 循环以及许多其他需要一个序列的地方 zip、map 等等。例如： 序列(sequence)类型： 如 list, str, tuple, bytes 等 非序列类型类型如：dict, 文件对象等 严格来说，可迭代对象是任何实现了 __iter__() 方法或者实现了序列(Sequence)语义中的 __getitem__() 方法的任意自定义类对象。 那么下面我们分别来讨论下这两种实现方案。 1. 实现 __iter__ 这种方式是你必须为你的类实现 __iter__()方法，该方法返回的必须是一个迭代器对象，下面会讲到。 2. 实现 __getitem__ 序列(Sequence)的迭代通过实现 __getitem__() 方法来使用整数索引进行高效的元素访问。同时，你必须为其定义一个返回序列长度的 __len__() 方法。例如上面例子中的 list, str, tuple, bytes。序列数据结构的存储是一段连续的内存空间，其直接使用整数索引进行寻址，查找元素非常高效，但是插入删除元素时效率低下。 有的童鞋会说，dict 也实现了 __getitem__ 和 __len__ 协议，为毛 dict 不属于序列？原因是它并不是通过整数索引来顺序迭代，而是通过任意的不可变键(immutable key) 来进行逐个查找的。所以 dict 的迭代还是因为其实现了 __iter__。 工作方式 当把一个可迭代对象 x 作为参数传给内置函数 iter() 时，它会返回该对象的迭代器以供迭代。但通常我们并不需要这么搞，当我们使用 for 对可迭代对象进行遍历时，for 语句会为你自动处理那些操作，即自动调用 iter(x) 来获取迭代器，若对象没有实现__iter__()方法，而实现了方式二的 __getitem__ 和 __len__ 协议，其会自动创建一个迭代器，并尝试从索引 0 开始获取元素，若尝试失败，会引发一个 TypeError。 类型断言 判断一个对象是否是一个可迭代对象，可以使用 collections.abc.Iterable。 In [1]: from collections.abc import Iterable In [2]: isinstance([1, 2, 3], Iterable) Out[2]: True In [3]: isinstance(1, Iterable) Out[3]: False In [4]: isinstance(&amp;#39;1&amp;#39;, Iterable) Out[4]: True In [5]: isinstance({}, Iterable) Out[5]: True 迭代器(iterator) 上面多次提到了迭代器，那么什么是迭代器？即实现了迭代器协议的对象就是一个迭代器，迭代器协议由 __iter__() 和 __next__() 共同组成。以 Golang 接口的思维理解就是任何实现了这俩方法的对象就是迭代器。 是的，又有 __iter__()，所以迭代器必定也是可迭代对象。在迭代器中: __iter__() 必须返回迭代器对象本身。 __next__() 应从容器中返回下一项，如果已经没有数据项可返回时，则需引发 StopIteration 异常，继续调用其 __next__() 应再次引发 StopIteration 异常。 所以一个迭代器应有的样子应该是这样的： class Iterator: def __iter__(self): return self def __next__(self): pass 工作方式 迭代器用来表示一连串数据流的对象，当 for 语句自动返回可迭代对象的迭代器时，for 将重复调用其 __next__() 方法将逐个返回流中的项，直到迭代器引发 StopIteration 异常后终止循环。此时该迭代器数据项已耗尽，不能再使用。我们可以通过将迭代器传给 next() 函数来模拟: In [11]: iterator = iter([1, 2, 3]) # 手动创建一个迭代器 In [12]: for i in iterator: ...: print(i) ...: 1 2 3 In [13]: next(iterator) # 该迭代器已耗尽 --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &amp;lt;ipython-input-13-4ce711c44abc&amp;gt; in &amp;lt;module&amp;gt; ----&amp;gt; 1 next(iterator) StopIteration: In [14]: iterator = iter([1, 2, 3]) In [15]: next(iterator) Out[15]: 1 In [16]: next(iterator) Out[16]: 2 In [17]: next(iterator) Out[17]: 3 In [18]: next(iterator) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &amp;lt;ipython-input-18-4ce711c44abc&amp;gt; in &amp;lt;module&amp;gt; ----&amp;gt; 1 next(iterator) StopIteration: 类型 判断一个对象是否是一个迭代器，可以使用 collections.abc.Iterator。 In [31]: from collections.abc import Iterator In [32]: iterator = iter([1, 2, 3]) In [33]: isinstance(iterator, Iterator) Out[33]: True In [34]: isinstance([],Iterator) Out[34]: False 练习 通过上面的介绍，你可能或多或少的了解了什么是可迭代对象 iterable，什么是迭代器 iterator。一句话简单的总结就是，当我们对可迭代对象进行迭代时，就从可迭代对象获取迭代器进行迭代。 下面我们来写一个非常简单的一段文本处理的示例，从下面一段 HTML 文本中提取出所有 a 标签的 href。 TEXT = (&amp;#39;&amp;lt;div&amp;gt;&amp;lt;a href=&amp;#34;https://blog.python.org&amp;#34; title=&amp;#34;More News&amp;#34;&amp;gt;More&amp;lt;/a&amp;gt;&amp;lt;ul class=&amp;#34;menu&amp;#34;&amp;gt;&amp;#39; &amp;#39;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;http://feedproxy.google.com/~r/PythonSoftwareFoundationNew/~3/T3r7qZxo-xg&amp;#39; &amp;#39;/python-software-foundation-fellow.html&amp;#34;&amp;gt;Python Software Foundation Fellow Members for&amp;#39; &amp;#39;Q3 2019&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;http://feedproxy.google.com/~r/PythonSoftwareFoundationNews&amp;#39; &amp;#39;/~3/lE0u-5MIUQc/why-sponsor-pycon-2020.html&amp;#34;&amp;gt;Why Sponsor PyCon 2020?&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;#39; &amp;#39;&amp;#34;http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/jAMRqiPhWSs/seeking-developers&amp;#39; &amp;#39;-for-paid-contract.html&amp;#34;&amp;gt;Developers for Paid Contract Improving pip&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;&amp;#39;) class LinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.findall(self.PATTERN, text) def __iter__(self): return LinkIiterator(self.links) class LinkIiterator: def __init__(self, links): self.links = links self.index = 0 def __iter__(self): return self def __next__(self): try: link = self.links[self.index] except IndexError: raise StopIteration self.index += 1 return link 稍稍验证一下: In [39]: for link in LinkFinder(TEXT): ...: print(link) ...: https://blog.python.org http://feedproxy.google.com/~r/PythonSoftwareFoundationNew/~3/T3r7qZxo-xg/python-software-foundation-fellow.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/lE0u-5MIUQc/why-sponsor-pycon-2020.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/jAMRqiPhWSs/seeking-developers-for-paid-contract.html 生成器(generator) 看完上面的例子，有同学可能会想，能不能省掉 LinkIiterator 呢？有没有一种机制能够让 __iter__() 返回的对象自动提供 __iter__() 和 __next__() 方法呢？ 有，那就是生成器（generator）。 一个包含 yield 的函数就是一个生成器函数(通常称其为生成器)，当其被调用的时，会返回一个迭代器，称为生成器迭代器(generator iterator)。yield 表达式会产生一系列值来供给 for 循环使用或是通过 next() 函数逐一获取。每个 yield 会临时暂停处理，记住当前位置执行状态(包括局部变量，指令指针，内部求值栈和任何异常处理的状态等)，当该生成器迭代器恢复时，它会从离开位置继续执行，这与每次调用都从新开始的普通函数差别很大。因本文主要讲迭代协议，所以关于生成器的实现部分暂不具体讨论。 生成器机制提供了一种实现迭代器协议的便捷方式。 即如果我们把容器对象 __iter__() 方法实现为一个生成器，那么它将返回一个生成器迭代器对象(generator iterator)，该对象提供 __iter__() 和 __next__() 方法以供迭代。 我们将上面的例子改成生成器版： class LinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.findall(self.PATTERN, text) def __iter__(self): for link in self.links: yield link 验证下： In [40]: for link in LinkFinder(TEXT): ...: print(link) ...: https://blog.python.org http://feedproxy.google.com/~r/PythonSoftwareFoundationNew/~3/T3r7qZxo-xg/python-software-foundation-fellow.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/lE0u-5MIUQc/why-sponsor-pycon-2020.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/jAMRqiPhWSs/seeking-developers-for-paid-contract.html 优化 本小节其实属于多余部分，关于迭代协议的讨论基本已经结束，但通过上面关于生成器的介绍我们发现，生成器迭代器与普通迭代器的一个显著区别就是，其往往是随用随生成，而不是一次性生成完毕，这在迭代大量数据时将非常有用，不用一次性计算或载入全部的数据到内存。所以上面的例子还有待优化。因为 links 列表是一次性计算好的。可以使用 re.finditer 方法，对 links 进行惰性求值： class LinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.finditer(self.PATTERN, text) def __iter__(self): for link in self.links: yield link.group() 还可以使用一种更加简洁的方式，即使用生成器表达式： def __iter__(self): return (link.group() for link in self.links)</description>
    </item>
    
    <item>
      <title>闲侃 sys.path 与 buildout 实践</title>
      <link>https://at7h.com/posts/py-syspath/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/py-syspath/</guid>
      <description>这篇文章我们来讨论下 Python 中的 sys.path，以及其在 buildout 中的应用与实践，最后分享下在 neo/vim 中给 python-mode 和 coc-python 添加自定义本地 Python 包路径的方法。 sys.path Python 中的 sys.path 是一个字符串列表，用于指定 Python Runtime 的模块搜索路径。 &amp;gt;&amp;gt;&amp;gt; import sys &amp;gt;&amp;gt;&amp;gt; sys.path [ &amp;#39;&amp;#39;, &amp;#39;/usr/local/lib/python27.zip&amp;#39;, &amp;#39;/usr/local/lib/python2.7&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-darwin&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac/lib-scriptpackages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-tk&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-old&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-dynload&amp;#39;, &amp;#39;/Users/jiawei/.local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages/install-1.3.3-py2.7.egg&amp;#39; ] 该列表由以下三个部分组成，在程序启动时，会从以下三个方面进行初始化: 1. 第一部分 sys.path[0] 是你当前调用 python 解释器的脚本的目录，也就是你当前的 Python 项目路径，如果是在 REPL 环境中，其为空字符串 &amp;quot;&amp;quot;。 2. 第二部分是开发者可以修改控制的，通过几种方式读取开发者定义的模块路径，例如通过读取环境变量 PYTHONPATH 等，下面具体介绍。 3. 最后一部分是你 Python 安装相关的默认环境。 当我们在程序中导入 import m 时，可能会遇到 ImportError: No module named m 这种类似的包无法导入的问题时，原因在于它所在的路径不在 sys.path 里，下面我将列举向 sys.path 添加自定义模块路径几种方法。 1. 通过创建 .pth 文件，将目录列出来，例如： /my/prodir1 /my/prodir2 但这种方式我们通常是不提倡的，关于更多如何使用 .pth 文件拓展 sys.path 的介绍可以阅读 site 模块的描述。 2. 通过设置环境变量 PYTHONPATH，写过 Go 的朋友应该都比较熟悉，类似于 Golang 中有 GOROOT 和 GOPATH。 export PYTHONPATH=/my/prodir1:/my/prodir2 现在再来看看我们的 sys.path &amp;gt;&amp;gt;&amp;gt; import sys &amp;gt;&amp;gt;&amp;gt; sys.path [ &amp;#39;&amp;#39;, &amp;#39;/my/prodir1&amp;#39;, &amp;#39;/my/prodir2&amp;#39;, &amp;#39;/usr/local/lib/python27.zip&amp;#39;, &amp;#39;/usr/local/lib/python2.7&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-darwin&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac/lib-scriptpackages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-tk&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-old&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-dynload&amp;#39;, &amp;#39;/Users/jiawei/.local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages/install-1.3.3-py2.7.egg&amp;#39; ] 3. 还有一种方式是写脚本来手动添加，在进入你程序的 work runtime 之前将路径插入到 sys.path中， 这种方式可以做到项目级，比较灵活： import sys sys.path.insert(0, &amp;#39;/my/prodir1&amp;#39;) sys.path.insert(0, &amp;#39;/my/prodir2&amp;#39;) 当然，上面只是一个简单的示例，实践中需要尽量避免硬编码，导致添加错误的路径。 buildout 对于一个 Python 开发者来说，虚拟环境工具你一定不陌生，例如 virtualenv，virtualenvwrapper，pipenv 等，它们通常提供了一个相对隔离的环境来存放和管理你需要的第三方包，并为你设置好 sys.path。不对，貌似有点跑题了，关于虚拟环境的工作原理我将在后面单独分享，下面请出本节的主角大哥大 buildout。 Buildout 是一个 Python 项目的自动化构建打包工具，通过它我们可以为大型系统创建复杂但可重用的设置。其主要根据配置将项目的依赖以 egg 包的形式全部归在统一的一个 eggs 目录下，这样就不用依赖任何外部的资源，比虚拟环境来得更彻底。egg 包 类似于 Java 中的 jar 包，想了解更多介绍的同学可以阅读这篇文章。 关于 buildout 的更多介绍和以及如何配置，官方文档上都有详细的介绍，而且因为本文的主题是 sys.path，所以这里就不赘述了。 这里我们主要关心它包的组织，eggs 会生成到你项目下的 buildout.cfg 配置中的 eggs-directory 目录下，而一般我们并不需要额外去配置，默认会生成在当前项目的根目录下，为你的项目使用。 当然 buildout 也支持在多个项目之间共享 eggs。这需要你新建 $HOME/.buildout/default.cfg 文件，设置用户级的默认配置： [buildout] eggs-directory = ~/.buildout/eggs download-cache = ~/.buildout/downloads 除此之外，你还可以通过每个 parts 下的 extra-paths 配置你本地的包： [buildout] parts = app [app] recipe = zc.recipe.egg interpreter = python eggs = my-pro-name extra-paths = ${buildout:directory}/my-extra-pkg 好，回到主题，既然是将依赖包打在项目里，所以要正确启动服务，buildout 肯定要将项目的所有依赖包 eggs 中的包路径以及 extra-paths 加入到 sys.path 中，它采用的方式是我们上面说的第三种，我们可以打开 bin 下生成的可执行文件一看便知： #!/Path/to/your/local/python import os, sys base = os.path.dirname(os.path.abspath(os.path.realpath(__file__))) base = os.path.dirname(base) sys.path[0:0] = [ base, &amp;#39;/path/to/local/pro/eggs/pkg1.egg&amp;#39;, &amp;#39;/path/to/local/pro/eggs/pkg2.egg&amp;#39;, # ... &amp;#39;/path/to/local/pro/my-extra-pkg&amp;#39; ] # ... 如果打包过程中，有一些包是你已经安装了，也就是在上面谈到的 sys.path 的第三部分的中的某个路径下，比如 /usr/local/lib/python2.7/site-packages, 那么在打包过程中就不会生成相应的 egg 包了，所以会在上述 sys.path 也会加上这个路径，因为 buildout 必须保证项目依赖包的完备性。 vim 插件支持 buildout 虽然很完美，但这也给 neo/vim 下的 Python 环境搭建带来了一点麻烦，据我所知目前的一些 Python 相关的插件并没有直接支持 buildout 的（PyCharm 是支持的，直接配置即可），所以并不能正确识别 buildout 的配置来加载我们项目的那些依赖包，在 rope init 或者 lint 时会报错找不到包，因此代码跳转补全等基础功能都会受到影响。所以我们必须要自己来处理这个问题，将上述依赖包加入到其运行时环境中。 当然你可以直接通过我们上述的几种方法来实现，但这不是我推荐的，因为配置环境变量等等都是全局的，幸好目前我用的几个插件都支持自定义包的拓展配置，比如 python-mode 和 coc-python。 1. 对于 pymode pymode 提供了 g:pymode_paths 数组来存放额外的包路径，所以在你的 pymode 配置中加入如下配置即可： if $BUILDOUT_EGGS_PATH != &amp;#39;&amp;#39; let g:pymode_paths = reverse(split(globpath($BUILDOUT_EGGS_PATH, &amp;#39;*&amp;#39;), &amp;#39;\n&amp;#39;)) else let g:pymode_paths = reverse(split(globpath(getcwd().&amp;#39;/eggs&amp;#39;, &amp;#39;*&amp;#39;), &amp;#39;\n&amp;#39;)) endif 在上面的配置中，如果你的 buildout 使用了多个项目共享 eggs 模式的话，为 BUILDOUT_EGGS_PATH 配置共享 eggs 的路径即可: export BUILDOUT_EGGS_PATH=/path/to/buildout/eggs/path 而如果并不是共享 eggs 的模式，那么项目的包都会在当前目录下的 eggs 中，就不用任何配置，配置会走到 else 逻辑自动获取包路径。 对于上述配置在 extra-paths 下的包可以: let g:pymode_paths = g:pymode_paths + reverse(split(getcwd().&amp;#39;/my-extra-pkg&amp;#39;, &amp;#39;\n&amp;#39;) 2. 对于 coc-python 同样的，coc-python 也提供了相应的配置： python.autoComplete.extraPaths: List of paths to libraries and the like that need to be imported by auto complete engine. E.g. when using Google App SDK, the paths are not in system path, hence need to be added into this list., default: [] 所以我们只需在 coc-settings.json 中加入相应配置即可，我们依旧使用上面的例子： { // ... &amp;#34;python.autoComplete.extraPaths&amp;#34;:[ &amp;#34;/path/to/local/pro/eggs/pkg1.egg&amp;#34;, &amp;#34;/path/to/local/pro/eggs/pkg2.egg&amp;#34;, &amp;#34;my-extra-pkg&amp;#34; ] // ... } 加入配置之后可以在 neo/vim COMMAND 模式下使用 CocInfo 命令来查看 path 的查找详情。 感兴趣的同学可以查看我的配置，同时也欢迎大家评论留言，与我交流。</description>
    </item>
    
    <item>
      <title>Python3 协程(coroutine)介绍</title>
      <link>https://at7h.com/posts/coroutine/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/coroutine/</guid>
      <description>目前 Python 语言的协程从实现来说可分为两类： 一种是基于传统生成器的协程，叫做 generator-based coroutines，通过包装 generator 对象实现。 另一种在 Python 3.5 版本 PEP 492 诞生，叫做 native coroutines，即通过使用 async 语法来声明的协程。 本文主要介绍第二种，第一种基于生成器的协程已在 Python 3.8 中弃用，并计划在 Python 3.10 中移除。本文是「介绍」，就先不讨论太多实现原理的东西，感兴趣的童鞋可以继续关注后面的文章。 协程(coroutine) 首先，来看一个非常简单的例子： import asyncio async def c(): await asyncio.sleep(1) return &amp;#39;Done 👌&amp;#39; 这个被 async 修饰的函数 c 就是一个协程函数，该函数会返回一个协程对象。 In [1]: asyncio.iscoroutinefunction(c) Out[1]: True In [2]: c() Out[2]: &amp;lt;coroutine object c at 0x107b0f748&amp;gt; In [3]: asyncio.iscoroutine(c()) Out[3]: True 一般来说，协程函数 c 应具有以下特点： 一定会返回一个协程对象，而不管其中是否有 await 表达式。 函数中不能再使用 yield from。 函数内部可通过 await 表达式来挂起自身协程，并等待另一个协程完成直到返回结果。 await 表达式后面可以跟的一定是一个可等待对象，而不仅仅是协程对象。 不可在 async 修饰的协程函数外使用 await 关键字，否则会引发一个 SyntaxError。 当对协程对象进行垃圾收集时，如果从未等待过它，则会引发一个 RuntimeWarning（如果你刚开始写 async，那你一定遇得到，不经意间就会忘掉一个 await)。 下面分别介绍下上面提到的两个概念，可等待对象和协程对象。 可等待对象(awaitable) 我们来看 collections.abc 模块中对 Awaitable 类的定义： class Awaitable(metaclass=ABCMeta): __slots__ = () @abstractmethod def __await__(self): yield @classmethod def __subclasshook__(cls, C): if cls is Awaitable: return _check_methods(C, &amp;#34;__await__&amp;#34;) return NotImplemented 可见，可等待对象主要实现了一个 __await__ 方法。且该方法必须返回一个迭代器(iterator) ①，否则将会引发一个 TypeError。 注意：主要实现是因为 await 表达式需要跟老的基于生成器的协程相兼容，即通过使用 types.coroutine() 或 asyncio.coroutine() 装饰器返回的生成器迭代器对象(generator iterator)也属于可等待对象，但它们并未实现 __await__ 方法。 协程对象(Coroutine) 同样的，我们来看 collections.abc 模块中对 Coroutine 类的定义： class Coroutine(Awaitable): __slots__ = () @abstractmethod def send(self, value): &amp;#34;&amp;#34;&amp;#34;Send a value into the coroutine. Return next yielded value or raise StopIteration. &amp;#34;&amp;#34;&amp;#34; raise StopIteration @abstractmethod def throw(self, typ, val=None, tb=None): &amp;#34;&amp;#34;&amp;#34;Raise an exception in the coroutine. Return next yielded value or raise StopIteration. &amp;#34;&amp;#34;&amp;#34; if val is None: if tb is None: raise typ val = typ() if tb is not None: val = val.with_traceback(tb) raise val def close(self): &amp;#34;&amp;#34;&amp;#34;Raise GeneratorExit inside coroutine. &amp;#34;&amp;#34;&amp;#34; try: self.throw(GeneratorExit) except (GeneratorExit, StopIteration): pass else: raise RuntimeError(&amp;#34;coroutine ignored GeneratorExit&amp;#34;) @classmethod def __subclasshook__(cls, C): if cls is Coroutine: return _check_methods(C, &amp;#39;__await__&amp;#39;, &amp;#39;send&amp;#39;, &amp;#39;throw&amp;#39;, &amp;#39;close&amp;#39;) return NotImplemented 由上可知，由于继承关系，协程对象是属于可等待对象的。 除了协程 Coroutine 对象外，目前常见的可等待对象还有两种：asyncio.Task 和 asyncio.Future，下文中介绍。 协程的执行可通过调用 __await__() 并迭代其结果进行控制。当协程结束执行并返回时，迭代器会引发 StopIteration 异常，并通过该异常的 value 属性来传播协程的返回值。下面看一个简单的例子： In [4]: c().send(None) Out[4]: &amp;lt;Future pending&amp;gt; In [5]: async def c1(): ...: return &amp;#34;Done 👌&amp;#34; ...: In [6]: c1().send(None) Out[6]: StopIteration: Done 👌 运行 协程的运行需要在一个 EventLoop 中进行，由它来控制异步任务的注册、执行、取消等。其大致原理是： 把传入的所有异步对象(准确的说是可等待对象，如 Coroutine，Task 等，见下文)都注册到这个 EventLoop 上，EventLoop 会循环执行这些异步对象，但同时只执行一个，当执行到某个对象时，如果它正在等待其他对象（I/O 处理） 返回，事件循环会暂停它的执行去执行其他的对象。当某个对象完成 I/O 处理后，下次循环到它的时候会获取其返回值然后继续向下执行。这样以来，所有的异步任务就可以协同运行。 EventLoop 接受的对象必须为可等待对象，目前主要有三种类型即 Coroutine, Task 和 Future。 下面简单的介绍下 Task 和 Future： Future 是一种特殊的低级的可等待对象，用来支持底层回调式代码与高层 async/await 式的代码交互，是对协程底层实现的封装，其表示一个异步操作的最终结果。它提供了设置和获取 Future 执行状态或结果等操作的接口。Future 实现了 __await__ 协议，并通过 __iter__ = __await__ 来兼容老式协程。一般来说，我们不需要关心这玩意儿，日常的开发也是不需要要用到它的。如有需要，就用其子类 Task。 Task 用来协同的调度协程以实现并发，并提供了相应的接口供我们使用。 创建一个 Task 非常简单： In [6]: loop = asyncio.get_event_loop() In [7]: task = loop.create_task(c()) In [8]: task Out[8]: &amp;lt;Task pending coro=&amp;lt;c() running at &amp;lt;ipython-input-1-3afd2bbb1944&amp;gt;:3&amp;gt;&amp;gt; In [9]: task.done() Out[9]: False In [10]: task.cancelled() Out[10]: False In [11]: task.result() Out[11]: InvalidStateError: Result is not set. In [12]: await task Out[12]: &amp;#39;Done 👌&amp;#39; In [13]: task Out[13]: &amp;lt;Task finished coro=&amp;lt;c() done, defined at &amp;lt;ipython-input-1-3afd2bbb1944&amp;gt;:3&amp;gt; result=&amp;#39;Done 👌&amp;#39;&amp;gt; In [14]: task.done() Out[14]: True In [15]: task.result() Out[15]: &amp;#39;Done 👌&amp;#39; In [16]: task = loop.create_task(c()) In [17]: task.cancel() Out[17]: True In [18]: await task Out[18]: CancelledError: 上面说到，协程的运行需要在一个 EventLoop 中进行，在 Python 3.7 之前，你只能这么写 😔 : In [19]: loop = asyncio.get_event_loop() In [20]: loop.run_until_complete(c()) Out[20]: &amp;#39;Done 👌&amp;#39; In [21]: loop.close() Python 3.7 及以上版本可以直接使用 asyncio.run() 👏 : In [22]: asyncio.run(c()) Out[22]: &amp;#39;Done 👌&amp;#39; 并发 有些童鞋可能有疑问了，我写好了一个个协程函数，怎样才能并发的运行 🤔 ？ asyncio 提供了相应的两个接口：asyncio.gather 和 asyncio.wait 来支持: async def c1(): await asyncio.sleep(1) print(&amp;#39;c1 done&amp;#39;) return True async def c2(): await asyncio.sleep(2) print(&amp;#39;c2 done&amp;#39;) return True async def c12_by_gather(): await asyncio.gather(c1(), c2()) async def c12_by_awit(): await asyncio.wait([c1(), c2()]) In [23]: asyncio.run(c12_by_gather()) c1 done c2 done In [24]: asyncio.run(c12_by_awit()) c1 done c2 done 其它 上面我们介绍了 PEP 492 coroutine 的基础使用，同时 PEP 492 也相应提出了基于 async with 和 async for 表达式的异步上下文管理器(asynchronous context manager)和异步迭代器(asynchronous iterator)。 下面的介绍的示例将基于 Python 可迭代对象, 迭代器和生成器 里的示例展开，建议感兴趣的同学可以先看下这篇文章。 异步上下文管理器 在 Python 中，我们常会通过实现 __enter__() 和 __exit__() 方法来实现一个上下文管理器： In [1]: class ContextManager: ...: ...: def __enter__(self): ...: print(&amp;#39;enter...&amp;#39;) ...: ...: def __exit__(slef, exc_type, exc_val, exc_tb): ...: print(&amp;#39;exit...&amp;#39;) ...: In [2]: with ContextManager(): ...: print(&amp;#39;Do something...&amp;#39;) ...: enter... Do something... exit... 同样的，在异步编程时我们可以通过实现 __aenter__() 和 __aexit__() 方法来实现一个上下文管理器，并通过 async with 表达式来使用。 In [1]: class AsyncContextManager: ...: ...: async def __aenter__(self): ...: print(&amp;#39;async enter...&amp;#39;) ...: ...: async def __aexit__(slef, exc_type, exc_val, exc_tb): ...: print(&amp;#39;async exit...&amp;#39;) ...: In [2]: async with AsyncContextManager(): ...: print(&amp;#39;Do something...&amp;#39;) ...: async enter... Do something... async exit... 异步迭代 在之前的文章 Python 可迭代对象, 迭代器和生成器 中，我们介绍了通过实现 __iter__() 方法来实现一个可迭代对象，通过实现迭代器协议 __iter__() 和 __next__() 方法来实现一个迭代器对象。下面我们改造下之前的例子，实现一个异步的版本。 class AsyncLinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.findall(self.PATTERN, text) def __aiter__(self): return AsyncLinkIiterator(self.links) class AsyncLinkIiterator: def __init__(self, links): self.links = links self.index = 0 async def _gen_link(self): try: link = self.links[self.index] self.index += 1 except IndexError: link = None return link def __aiter__(self): return self async def __anext__(self): link = await self._gen_link() if link is None: raise StopAsyncIteration return link In [7]: async for s in AsyncLinkFinder(TEXT): ...: print(s) https://blog.python.org http://feedproxy.google.com/~r/PythonSoftwareFoundationNew/~3/T3r7qZxo-xg/python-software-foundation-fellow.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/lE0u-5MIUQc/why-sponsor-pycon-2020.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/jAMRqiPhWSs/seeking-developers-for-paid-contract.html 例子中实现了 __aiter__() 方法的 AsyncLinkFinder 就是一个异步可迭代对象，__aiter__() 方法返回的必须是一个异步迭代器，如 AsyncLinkIiterator。异步迭代器必须同时实现 __aiter__() 和 __anext__() 方法。一个不同的点是，异步迭代中，当迭代器耗尽时，需要引发一个 StopAsyncIteration 而不是 StopIteration。 同样的，我们也实现一个异步生成器版本的： class LinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.finditer(self.PATTERN, text) async def __aiter__(self): return (link.group() for link in self.links) 注 ① 关于迭代器的介绍可阅读 Python 可迭代对象, 迭代器和生成器。 ② 关于示例中 __slots__ 的介绍请查看 理解 Python 类属性之 __slots__。 参考 PEP 492: Coroutines with async and await syntax PEP 342: Coroutines via Enhanced Generators</description>
    </item>
    
  </channel>
</rss>